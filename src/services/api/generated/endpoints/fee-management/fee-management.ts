// @ts-nocheck
/**
 * Generated by orval v8.3.0 ðŸº
 * Do not edit manually.
 * API
 * API docs
 * OpenAPI spec version: 1.0
 */
import { useInfiniteQuery, useMutation, useQuery } from "@tanstack/react-query";
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  ApplyConcessionDto,
  CreateFeeStructureDto,
  FeesControllerGetCollectionReportV1Params,
  GenerateBulkChallanDto,
  GenerateChallanDto,
  RecordPaymentDto,
  SendRemindersDto,
} from "../../models";

import { customFetch } from "../../custom-fetch";

export type feesControllerCreateStructureV1Response201 = {
  data: void;
  status: 201;
};

export type feesControllerCreateStructureV1ResponseSuccess =
  feesControllerCreateStructureV1Response201 & {
    headers: Headers;
  };
export type feesControllerCreateStructureV1Response =
  feesControllerCreateStructureV1ResponseSuccess;

export const getFeesControllerCreateStructureV1Url = () => {
  return `http://localhost:3000/api/v1/fees/structures`;
};

export const feesControllerCreateStructureV1 = async (
  createFeeStructureDto: CreateFeeStructureDto,
  options?: RequestInit
): Promise<feesControllerCreateStructureV1Response> => {
  return customFetch<feesControllerCreateStructureV1Response>(
    getFeesControllerCreateStructureV1Url(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(createFeeStructureDto),
    }
  );
};

export const getFeesControllerCreateStructureV1MutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof feesControllerCreateStructureV1>>,
    TError,
    { data: CreateFeeStructureDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof feesControllerCreateStructureV1>>,
  TError,
  { data: CreateFeeStructureDto },
  TContext
> => {
  const mutationKey = ["feesControllerCreateStructureV1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof feesControllerCreateStructureV1>>,
    { data: CreateFeeStructureDto }
  > = (props) => {
    const { data } = props ?? {};

    return feesControllerCreateStructureV1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type FeesControllerCreateStructureV1MutationResult = NonNullable<
  Awaited<ReturnType<typeof feesControllerCreateStructureV1>>
>;
export type FeesControllerCreateStructureV1MutationBody = CreateFeeStructureDto;
export type FeesControllerCreateStructureV1MutationError = unknown;

export const useFeesControllerCreateStructureV1 = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof feesControllerCreateStructureV1>>,
    TError,
    { data: CreateFeeStructureDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof feesControllerCreateStructureV1>>,
  TError,
  { data: CreateFeeStructureDto },
  TContext
> => {
  return useMutation(
    getFeesControllerCreateStructureV1MutationOptions(options)
  );
};
export type feesControllerGetStructureV1Response200 = {
  data: void;
  status: 200;
};

export type feesControllerGetStructureV1ResponseSuccess =
  feesControllerGetStructureV1Response200 & {
    headers: Headers;
  };
export type feesControllerGetStructureV1Response =
  feesControllerGetStructureV1ResponseSuccess;

export const getFeesControllerGetStructureV1Url = (id: number) => {
  return `http://localhost:3000/api/v1/fees/structures/${id}`;
};

export const feesControllerGetStructureV1 = async (
  id: number,
  options?: RequestInit
): Promise<feesControllerGetStructureV1Response> => {
  return customFetch<feesControllerGetStructureV1Response>(
    getFeesControllerGetStructureV1Url(id),
    {
      ...options,
      method: "GET",
    }
  );
};

export const getFeesControllerGetStructureV1InfiniteQueryKey = (id: number) => {
  return [
    "infinite",
    `http://localhost:3000/api/v1/fees/structures/${id}`,
  ] as const;
};

export const getFeesControllerGetStructureV1QueryKey = (id: number) => {
  return [`http://localhost:3000/api/v1/fees/structures/${id}`] as const;
};

export const getFeesControllerGetStructureV1InfiniteQueryOptions = <
  TData = Awaited<ReturnType<typeof feesControllerGetStructureV1>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof feesControllerGetStructureV1>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getFeesControllerGetStructureV1InfiniteQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof feesControllerGetStructureV1>>
  > = ({ signal }) => feesControllerGetStructureV1(id, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof feesControllerGetStructureV1>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type FeesControllerGetStructureV1InfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof feesControllerGetStructureV1>>
>;
export type FeesControllerGetStructureV1InfiniteQueryError = unknown;

export function useFeesControllerGetStructureV1Infinite<
  TData = Awaited<ReturnType<typeof feesControllerGetStructureV1>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof feesControllerGetStructureV1>>,
      TError,
      TData
    >;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getFeesControllerGetStructureV1InfiniteQueryOptions(
    id,
    options
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const getFeesControllerGetStructureV1QueryOptions = <
  TData = Awaited<ReturnType<typeof feesControllerGetStructureV1>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof feesControllerGetStructureV1>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFeesControllerGetStructureV1QueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof feesControllerGetStructureV1>>
  > = ({ signal }) => feesControllerGetStructureV1(id, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof feesControllerGetStructureV1>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type FeesControllerGetStructureV1QueryResult = NonNullable<
  Awaited<ReturnType<typeof feesControllerGetStructureV1>>
>;
export type FeesControllerGetStructureV1QueryError = unknown;

export function useFeesControllerGetStructureV1<
  TData = Awaited<ReturnType<typeof feesControllerGetStructureV1>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof feesControllerGetStructureV1>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getFeesControllerGetStructureV1QueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

export type feesControllerGenerateChallanV1Response201 = {
  data: void;
  status: 201;
};

export type feesControllerGenerateChallanV1ResponseSuccess =
  feesControllerGenerateChallanV1Response201 & {
    headers: Headers;
  };
export type feesControllerGenerateChallanV1Response =
  feesControllerGenerateChallanV1ResponseSuccess;

export const getFeesControllerGenerateChallanV1Url = () => {
  return `http://localhost:3000/api/v1/fees/challans/generate`;
};

export const feesControllerGenerateChallanV1 = async (
  generateChallanDto: GenerateChallanDto,
  options?: RequestInit
): Promise<feesControllerGenerateChallanV1Response> => {
  return customFetch<feesControllerGenerateChallanV1Response>(
    getFeesControllerGenerateChallanV1Url(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(generateChallanDto),
    }
  );
};

export const getFeesControllerGenerateChallanV1MutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof feesControllerGenerateChallanV1>>,
    TError,
    { data: GenerateChallanDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof feesControllerGenerateChallanV1>>,
  TError,
  { data: GenerateChallanDto },
  TContext
> => {
  const mutationKey = ["feesControllerGenerateChallanV1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof feesControllerGenerateChallanV1>>,
    { data: GenerateChallanDto }
  > = (props) => {
    const { data } = props ?? {};

    return feesControllerGenerateChallanV1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type FeesControllerGenerateChallanV1MutationResult = NonNullable<
  Awaited<ReturnType<typeof feesControllerGenerateChallanV1>>
>;
export type FeesControllerGenerateChallanV1MutationBody = GenerateChallanDto;
export type FeesControllerGenerateChallanV1MutationError = unknown;

export const useFeesControllerGenerateChallanV1 = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof feesControllerGenerateChallanV1>>,
    TError,
    { data: GenerateChallanDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof feesControllerGenerateChallanV1>>,
  TError,
  { data: GenerateChallanDto },
  TContext
> => {
  return useMutation(
    getFeesControllerGenerateChallanV1MutationOptions(options)
  );
};
export type feesControllerGenerateBulkChallansV1Response201 = {
  data: void;
  status: 201;
};

export type feesControllerGenerateBulkChallansV1ResponseSuccess =
  feesControllerGenerateBulkChallansV1Response201 & {
    headers: Headers;
  };
export type feesControllerGenerateBulkChallansV1Response =
  feesControllerGenerateBulkChallansV1ResponseSuccess;

export const getFeesControllerGenerateBulkChallansV1Url = () => {
  return `http://localhost:3000/api/v1/fees/challans/generate-bulk`;
};

export const feesControllerGenerateBulkChallansV1 = async (
  generateBulkChallanDto: GenerateBulkChallanDto,
  options?: RequestInit
): Promise<feesControllerGenerateBulkChallansV1Response> => {
  return customFetch<feesControllerGenerateBulkChallansV1Response>(
    getFeesControllerGenerateBulkChallansV1Url(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(generateBulkChallanDto),
    }
  );
};

export const getFeesControllerGenerateBulkChallansV1MutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof feesControllerGenerateBulkChallansV1>>,
    TError,
    { data: GenerateBulkChallanDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof feesControllerGenerateBulkChallansV1>>,
  TError,
  { data: GenerateBulkChallanDto },
  TContext
> => {
  const mutationKey = ["feesControllerGenerateBulkChallansV1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof feesControllerGenerateBulkChallansV1>>,
    { data: GenerateBulkChallanDto }
  > = (props) => {
    const { data } = props ?? {};

    return feesControllerGenerateBulkChallansV1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type FeesControllerGenerateBulkChallansV1MutationResult = NonNullable<
  Awaited<ReturnType<typeof feesControllerGenerateBulkChallansV1>>
>;
export type FeesControllerGenerateBulkChallansV1MutationBody =
  GenerateBulkChallanDto;
export type FeesControllerGenerateBulkChallansV1MutationError = unknown;

export const useFeesControllerGenerateBulkChallansV1 = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof feesControllerGenerateBulkChallansV1>>,
    TError,
    { data: GenerateBulkChallanDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof feesControllerGenerateBulkChallansV1>>,
  TError,
  { data: GenerateBulkChallanDto },
  TContext
> => {
  return useMutation(
    getFeesControllerGenerateBulkChallansV1MutationOptions(options)
  );
};
export type feesControllerGetChallanV1Response200 = {
  data: void;
  status: 200;
};

export type feesControllerGetChallanV1ResponseSuccess =
  feesControllerGetChallanV1Response200 & {
    headers: Headers;
  };
export type feesControllerGetChallanV1Response =
  feesControllerGetChallanV1ResponseSuccess;

export const getFeesControllerGetChallanV1Url = (challanNumber: string) => {
  return `http://localhost:3000/api/v1/fees/challans/${challanNumber}`;
};

export const feesControllerGetChallanV1 = async (
  challanNumber: string,
  options?: RequestInit
): Promise<feesControllerGetChallanV1Response> => {
  return customFetch<feesControllerGetChallanV1Response>(
    getFeesControllerGetChallanV1Url(challanNumber),
    {
      ...options,
      method: "GET",
    }
  );
};

export const getFeesControllerGetChallanV1InfiniteQueryKey = (
  challanNumber: string
) => {
  return [
    "infinite",
    `http://localhost:3000/api/v1/fees/challans/${challanNumber}`,
  ] as const;
};

export const getFeesControllerGetChallanV1QueryKey = (
  challanNumber: string
) => {
  return [
    `http://localhost:3000/api/v1/fees/challans/${challanNumber}`,
  ] as const;
};

export const getFeesControllerGetChallanV1InfiniteQueryOptions = <
  TData = Awaited<ReturnType<typeof feesControllerGetChallanV1>>,
  TError = unknown,
>(
  challanNumber: string,
  options?: {
    query?: UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof feesControllerGetChallanV1>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getFeesControllerGetChallanV1InfiniteQueryKey(challanNumber);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof feesControllerGetChallanV1>>
  > = ({ signal }) => feesControllerGetChallanV1(challanNumber, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!challanNumber,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof feesControllerGetChallanV1>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type FeesControllerGetChallanV1InfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof feesControllerGetChallanV1>>
>;
export type FeesControllerGetChallanV1InfiniteQueryError = unknown;

export function useFeesControllerGetChallanV1Infinite<
  TData = Awaited<ReturnType<typeof feesControllerGetChallanV1>>,
  TError = unknown,
>(
  challanNumber: string,
  options?: {
    query?: UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof feesControllerGetChallanV1>>,
      TError,
      TData
    >;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getFeesControllerGetChallanV1InfiniteQueryOptions(
    challanNumber,
    options
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const getFeesControllerGetChallanV1QueryOptions = <
  TData = Awaited<ReturnType<typeof feesControllerGetChallanV1>>,
  TError = unknown,
>(
  challanNumber: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof feesControllerGetChallanV1>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getFeesControllerGetChallanV1QueryKey(challanNumber);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof feesControllerGetChallanV1>>
  > = ({ signal }) => feesControllerGetChallanV1(challanNumber, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!challanNumber,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof feesControllerGetChallanV1>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type FeesControllerGetChallanV1QueryResult = NonNullable<
  Awaited<ReturnType<typeof feesControllerGetChallanV1>>
>;
export type FeesControllerGetChallanV1QueryError = unknown;

export function useFeesControllerGetChallanV1<
  TData = Awaited<ReturnType<typeof feesControllerGetChallanV1>>,
  TError = unknown,
>(
  challanNumber: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof feesControllerGetChallanV1>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getFeesControllerGetChallanV1QueryOptions(
    challanNumber,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

export type feesControllerRecordPaymentV1Response201 = {
  data: void;
  status: 201;
};

export type feesControllerRecordPaymentV1ResponseSuccess =
  feesControllerRecordPaymentV1Response201 & {
    headers: Headers;
  };
export type feesControllerRecordPaymentV1Response =
  feesControllerRecordPaymentV1ResponseSuccess;

export const getFeesControllerRecordPaymentV1Url = () => {
  return `http://localhost:3000/api/v1/fees/payments`;
};

export const feesControllerRecordPaymentV1 = async (
  recordPaymentDto: RecordPaymentDto,
  options?: RequestInit
): Promise<feesControllerRecordPaymentV1Response> => {
  return customFetch<feesControllerRecordPaymentV1Response>(
    getFeesControllerRecordPaymentV1Url(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(recordPaymentDto),
    }
  );
};

export const getFeesControllerRecordPaymentV1MutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof feesControllerRecordPaymentV1>>,
    TError,
    { data: RecordPaymentDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof feesControllerRecordPaymentV1>>,
  TError,
  { data: RecordPaymentDto },
  TContext
> => {
  const mutationKey = ["feesControllerRecordPaymentV1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof feesControllerRecordPaymentV1>>,
    { data: RecordPaymentDto }
  > = (props) => {
    const { data } = props ?? {};

    return feesControllerRecordPaymentV1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type FeesControllerRecordPaymentV1MutationResult = NonNullable<
  Awaited<ReturnType<typeof feesControllerRecordPaymentV1>>
>;
export type FeesControllerRecordPaymentV1MutationBody = RecordPaymentDto;
export type FeesControllerRecordPaymentV1MutationError = unknown;

export const useFeesControllerRecordPaymentV1 = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof feesControllerRecordPaymentV1>>,
    TError,
    { data: RecordPaymentDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof feesControllerRecordPaymentV1>>,
  TError,
  { data: RecordPaymentDto },
  TContext
> => {
  return useMutation(getFeesControllerRecordPaymentV1MutationOptions(options));
};
export type feesControllerVerifyPaymentV1Response200 = {
  data: void;
  status: 200;
};

export type feesControllerVerifyPaymentV1ResponseSuccess =
  feesControllerVerifyPaymentV1Response200 & {
    headers: Headers;
  };
export type feesControllerVerifyPaymentV1Response =
  feesControllerVerifyPaymentV1ResponseSuccess;

export const getFeesControllerVerifyPaymentV1Url = (id: number) => {
  return `http://localhost:3000/api/v1/fees/payments/${id}/verify`;
};

export const feesControllerVerifyPaymentV1 = async (
  id: number,
  options?: RequestInit
): Promise<feesControllerVerifyPaymentV1Response> => {
  return customFetch<feesControllerVerifyPaymentV1Response>(
    getFeesControllerVerifyPaymentV1Url(id),
    {
      ...options,
      method: "PATCH",
    }
  );
};

export const getFeesControllerVerifyPaymentV1MutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof feesControllerVerifyPaymentV1>>,
    TError,
    { id: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof feesControllerVerifyPaymentV1>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationKey = ["feesControllerVerifyPaymentV1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof feesControllerVerifyPaymentV1>>,
    { id: number }
  > = (props) => {
    const { id } = props ?? {};

    return feesControllerVerifyPaymentV1(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type FeesControllerVerifyPaymentV1MutationResult = NonNullable<
  Awaited<ReturnType<typeof feesControllerVerifyPaymentV1>>
>;

export type FeesControllerVerifyPaymentV1MutationError = unknown;

export const useFeesControllerVerifyPaymentV1 = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof feesControllerVerifyPaymentV1>>,
    TError,
    { id: number },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof feesControllerVerifyPaymentV1>>,
  TError,
  { id: number },
  TContext
> => {
  return useMutation(getFeesControllerVerifyPaymentV1MutationOptions(options));
};
export type feesControllerApplyConcessionV1Response201 = {
  data: void;
  status: 201;
};

export type feesControllerApplyConcessionV1ResponseSuccess =
  feesControllerApplyConcessionV1Response201 & {
    headers: Headers;
  };
export type feesControllerApplyConcessionV1Response =
  feesControllerApplyConcessionV1ResponseSuccess;

export const getFeesControllerApplyConcessionV1Url = () => {
  return `http://localhost:3000/api/v1/fees/concessions`;
};

export const feesControllerApplyConcessionV1 = async (
  applyConcessionDto: ApplyConcessionDto,
  options?: RequestInit
): Promise<feesControllerApplyConcessionV1Response> => {
  return customFetch<feesControllerApplyConcessionV1Response>(
    getFeesControllerApplyConcessionV1Url(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(applyConcessionDto),
    }
  );
};

export const getFeesControllerApplyConcessionV1MutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof feesControllerApplyConcessionV1>>,
    TError,
    { data: ApplyConcessionDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof feesControllerApplyConcessionV1>>,
  TError,
  { data: ApplyConcessionDto },
  TContext
> => {
  const mutationKey = ["feesControllerApplyConcessionV1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof feesControllerApplyConcessionV1>>,
    { data: ApplyConcessionDto }
  > = (props) => {
    const { data } = props ?? {};

    return feesControllerApplyConcessionV1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type FeesControllerApplyConcessionV1MutationResult = NonNullable<
  Awaited<ReturnType<typeof feesControllerApplyConcessionV1>>
>;
export type FeesControllerApplyConcessionV1MutationBody = ApplyConcessionDto;
export type FeesControllerApplyConcessionV1MutationError = unknown;

export const useFeesControllerApplyConcessionV1 = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof feesControllerApplyConcessionV1>>,
    TError,
    { data: ApplyConcessionDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof feesControllerApplyConcessionV1>>,
  TError,
  { data: ApplyConcessionDto },
  TContext
> => {
  return useMutation(
    getFeesControllerApplyConcessionV1MutationOptions(options)
  );
};
export type feesControllerGetEffectiveConcessionV1Response200 = {
  data: void;
  status: 200;
};

export type feesControllerGetEffectiveConcessionV1ResponseSuccess =
  feesControllerGetEffectiveConcessionV1Response200 & {
    headers: Headers;
  };
export type feesControllerGetEffectiveConcessionV1Response =
  feesControllerGetEffectiveConcessionV1ResponseSuccess;

export const getFeesControllerGetEffectiveConcessionV1Url = (id: number) => {
  return `http://localhost:3000/api/v1/fees/students/${id}/effective-concession`;
};

export const feesControllerGetEffectiveConcessionV1 = async (
  id: number,
  options?: RequestInit
): Promise<feesControllerGetEffectiveConcessionV1Response> => {
  return customFetch<feesControllerGetEffectiveConcessionV1Response>(
    getFeesControllerGetEffectiveConcessionV1Url(id),
    {
      ...options,
      method: "GET",
    }
  );
};

export const getFeesControllerGetEffectiveConcessionV1InfiniteQueryKey = (
  id: number
) => {
  return [
    "infinite",
    `http://localhost:3000/api/v1/fees/students/${id}/effective-concession`,
  ] as const;
};

export const getFeesControllerGetEffectiveConcessionV1QueryKey = (
  id: number
) => {
  return [
    `http://localhost:3000/api/v1/fees/students/${id}/effective-concession`,
  ] as const;
};

export const getFeesControllerGetEffectiveConcessionV1InfiniteQueryOptions = <
  TData = Awaited<ReturnType<typeof feesControllerGetEffectiveConcessionV1>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof feesControllerGetEffectiveConcessionV1>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getFeesControllerGetEffectiveConcessionV1InfiniteQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof feesControllerGetEffectiveConcessionV1>>
  > = ({ signal }) => feesControllerGetEffectiveConcessionV1(id, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof feesControllerGetEffectiveConcessionV1>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type FeesControllerGetEffectiveConcessionV1InfiniteQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof feesControllerGetEffectiveConcessionV1>>
  >;
export type FeesControllerGetEffectiveConcessionV1InfiniteQueryError = unknown;

export function useFeesControllerGetEffectiveConcessionV1Infinite<
  TData = Awaited<ReturnType<typeof feesControllerGetEffectiveConcessionV1>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof feesControllerGetEffectiveConcessionV1>>,
      TError,
      TData
    >;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions =
    getFeesControllerGetEffectiveConcessionV1InfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const getFeesControllerGetEffectiveConcessionV1QueryOptions = <
  TData = Awaited<ReturnType<typeof feesControllerGetEffectiveConcessionV1>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof feesControllerGetEffectiveConcessionV1>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getFeesControllerGetEffectiveConcessionV1QueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof feesControllerGetEffectiveConcessionV1>>
  > = ({ signal }) => feesControllerGetEffectiveConcessionV1(id, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof feesControllerGetEffectiveConcessionV1>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type FeesControllerGetEffectiveConcessionV1QueryResult = NonNullable<
  Awaited<ReturnType<typeof feesControllerGetEffectiveConcessionV1>>
>;
export type FeesControllerGetEffectiveConcessionV1QueryError = unknown;

export function useFeesControllerGetEffectiveConcessionV1<
  TData = Awaited<ReturnType<typeof feesControllerGetEffectiveConcessionV1>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof feesControllerGetEffectiveConcessionV1>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getFeesControllerGetEffectiveConcessionV1QueryOptions(
    id,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

export type feesControllerGetReceiptPdfV1Response200 = {
  data: void;
  status: 200;
};

export type feesControllerGetReceiptPdfV1ResponseSuccess =
  feesControllerGetReceiptPdfV1Response200 & {
    headers: Headers;
  };
export type feesControllerGetReceiptPdfV1Response =
  feesControllerGetReceiptPdfV1ResponseSuccess;

export const getFeesControllerGetReceiptPdfV1Url = (id: number) => {
  return `http://localhost:3000/api/v1/fees/receipts/${id}/pdf`;
};

export const feesControllerGetReceiptPdfV1 = async (
  id: number,
  options?: RequestInit
): Promise<feesControllerGetReceiptPdfV1Response> => {
  return customFetch<feesControllerGetReceiptPdfV1Response>(
    getFeesControllerGetReceiptPdfV1Url(id),
    {
      ...options,
      method: "GET",
    }
  );
};

export const getFeesControllerGetReceiptPdfV1InfiniteQueryKey = (
  id: number
) => {
  return [
    "infinite",
    `http://localhost:3000/api/v1/fees/receipts/${id}/pdf`,
  ] as const;
};

export const getFeesControllerGetReceiptPdfV1QueryKey = (id: number) => {
  return [`http://localhost:3000/api/v1/fees/receipts/${id}/pdf`] as const;
};

export const getFeesControllerGetReceiptPdfV1InfiniteQueryOptions = <
  TData = Awaited<ReturnType<typeof feesControllerGetReceiptPdfV1>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof feesControllerGetReceiptPdfV1>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getFeesControllerGetReceiptPdfV1InfiniteQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof feesControllerGetReceiptPdfV1>>
  > = ({ signal }) => feesControllerGetReceiptPdfV1(id, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof feesControllerGetReceiptPdfV1>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type FeesControllerGetReceiptPdfV1InfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof feesControllerGetReceiptPdfV1>>
>;
export type FeesControllerGetReceiptPdfV1InfiniteQueryError = unknown;

export function useFeesControllerGetReceiptPdfV1Infinite<
  TData = Awaited<ReturnType<typeof feesControllerGetReceiptPdfV1>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof feesControllerGetReceiptPdfV1>>,
      TError,
      TData
    >;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getFeesControllerGetReceiptPdfV1InfiniteQueryOptions(
    id,
    options
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const getFeesControllerGetReceiptPdfV1QueryOptions = <
  TData = Awaited<ReturnType<typeof feesControllerGetReceiptPdfV1>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof feesControllerGetReceiptPdfV1>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFeesControllerGetReceiptPdfV1QueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof feesControllerGetReceiptPdfV1>>
  > = ({ signal }) => feesControllerGetReceiptPdfV1(id, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof feesControllerGetReceiptPdfV1>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type FeesControllerGetReceiptPdfV1QueryResult = NonNullable<
  Awaited<ReturnType<typeof feesControllerGetReceiptPdfV1>>
>;
export type FeesControllerGetReceiptPdfV1QueryError = unknown;

export function useFeesControllerGetReceiptPdfV1<
  TData = Awaited<ReturnType<typeof feesControllerGetReceiptPdfV1>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof feesControllerGetReceiptPdfV1>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getFeesControllerGetReceiptPdfV1QueryOptions(
    id,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

export type feesControllerGetCollectionReportV1Response200 = {
  data: void;
  status: 200;
};

export type feesControllerGetCollectionReportV1ResponseSuccess =
  feesControllerGetCollectionReportV1Response200 & {
    headers: Headers;
  };
export type feesControllerGetCollectionReportV1Response =
  feesControllerGetCollectionReportV1ResponseSuccess;

export const getFeesControllerGetCollectionReportV1Url = (
  params?: FeesControllerGetCollectionReportV1Params
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `http://localhost:3000/api/v1/fees/reports/collection?${stringifiedParams}`
    : `http://localhost:3000/api/v1/fees/reports/collection`;
};

export const feesControllerGetCollectionReportV1 = async (
  params?: FeesControllerGetCollectionReportV1Params,
  options?: RequestInit
): Promise<feesControllerGetCollectionReportV1Response> => {
  return customFetch<feesControllerGetCollectionReportV1Response>(
    getFeesControllerGetCollectionReportV1Url(params),
    {
      ...options,
      method: "GET",
    }
  );
};

export const getFeesControllerGetCollectionReportV1InfiniteQueryKey = (
  params?: FeesControllerGetCollectionReportV1Params
) => {
  return [
    "infinite",
    `http://localhost:3000/api/v1/fees/reports/collection`,
    ...(params ? [params] : []),
  ] as const;
};

export const getFeesControllerGetCollectionReportV1QueryKey = (
  params?: FeesControllerGetCollectionReportV1Params
) => {
  return [
    `http://localhost:3000/api/v1/fees/reports/collection`,
    ...(params ? [params] : []),
  ] as const;
};

export const getFeesControllerGetCollectionReportV1InfiniteQueryOptions = <
  TData = Awaited<ReturnType<typeof feesControllerGetCollectionReportV1>>,
  TError = unknown,
>(
  params?: FeesControllerGetCollectionReportV1Params,
  options?: {
    query?: UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof feesControllerGetCollectionReportV1>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getFeesControllerGetCollectionReportV1InfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof feesControllerGetCollectionReportV1>>
  > = ({ signal, pageParam }) =>
    feesControllerGetCollectionReportV1(
      { ...params, page: pageParam || params?.["page"] },
      { signal }
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof feesControllerGetCollectionReportV1>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type FeesControllerGetCollectionReportV1InfiniteQueryResult =
  NonNullable<Awaited<ReturnType<typeof feesControllerGetCollectionReportV1>>>;
export type FeesControllerGetCollectionReportV1InfiniteQueryError = unknown;

export function useFeesControllerGetCollectionReportV1Infinite<
  TData = Awaited<ReturnType<typeof feesControllerGetCollectionReportV1>>,
  TError = unknown,
>(
  params?: FeesControllerGetCollectionReportV1Params,
  options?: {
    query?: UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof feesControllerGetCollectionReportV1>>,
      TError,
      TData
    >;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions =
    getFeesControllerGetCollectionReportV1InfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const getFeesControllerGetCollectionReportV1QueryOptions = <
  TData = Awaited<ReturnType<typeof feesControllerGetCollectionReportV1>>,
  TError = unknown,
>(
  params?: FeesControllerGetCollectionReportV1Params,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof feesControllerGetCollectionReportV1>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getFeesControllerGetCollectionReportV1QueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof feesControllerGetCollectionReportV1>>
  > = ({ signal }) => feesControllerGetCollectionReportV1(params, { signal });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof feesControllerGetCollectionReportV1>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type FeesControllerGetCollectionReportV1QueryResult = NonNullable<
  Awaited<ReturnType<typeof feesControllerGetCollectionReportV1>>
>;
export type FeesControllerGetCollectionReportV1QueryError = unknown;

export function useFeesControllerGetCollectionReportV1<
  TData = Awaited<ReturnType<typeof feesControllerGetCollectionReportV1>>,
  TError = unknown,
>(
  params?: FeesControllerGetCollectionReportV1Params,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof feesControllerGetCollectionReportV1>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getFeesControllerGetCollectionReportV1QueryOptions(
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

export type feesControllerGetPendingReportV1Response200 = {
  data: void;
  status: 200;
};

export type feesControllerGetPendingReportV1ResponseSuccess =
  feesControllerGetPendingReportV1Response200 & {
    headers: Headers;
  };
export type feesControllerGetPendingReportV1Response =
  feesControllerGetPendingReportV1ResponseSuccess;

export const getFeesControllerGetPendingReportV1Url = () => {
  return `http://localhost:3000/api/v1/fees/reports/pending`;
};

export const feesControllerGetPendingReportV1 = async (
  options?: RequestInit
): Promise<feesControllerGetPendingReportV1Response> => {
  return customFetch<feesControllerGetPendingReportV1Response>(
    getFeesControllerGetPendingReportV1Url(),
    {
      ...options,
      method: "GET",
    }
  );
};

export const getFeesControllerGetPendingReportV1InfiniteQueryKey = () => {
  return [
    "infinite",
    `http://localhost:3000/api/v1/fees/reports/pending`,
  ] as const;
};

export const getFeesControllerGetPendingReportV1QueryKey = () => {
  return [`http://localhost:3000/api/v1/fees/reports/pending`] as const;
};

export const getFeesControllerGetPendingReportV1InfiniteQueryOptions = <
  TData = Awaited<ReturnType<typeof feesControllerGetPendingReportV1>>,
  TError = unknown,
>(options?: {
  query?: UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof feesControllerGetPendingReportV1>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getFeesControllerGetPendingReportV1InfiniteQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof feesControllerGetPendingReportV1>>
  > = ({ signal }) => feesControllerGetPendingReportV1({ signal });

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof feesControllerGetPendingReportV1>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type FeesControllerGetPendingReportV1InfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof feesControllerGetPendingReportV1>>
>;
export type FeesControllerGetPendingReportV1InfiniteQueryError = unknown;

export function useFeesControllerGetPendingReportV1Infinite<
  TData = Awaited<ReturnType<typeof feesControllerGetPendingReportV1>>,
  TError = unknown,
>(options?: {
  query?: UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof feesControllerGetPendingReportV1>>,
    TError,
    TData
  >;
}): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions =
    getFeesControllerGetPendingReportV1InfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const getFeesControllerGetPendingReportV1QueryOptions = <
  TData = Awaited<ReturnType<typeof feesControllerGetPendingReportV1>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof feesControllerGetPendingReportV1>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFeesControllerGetPendingReportV1QueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof feesControllerGetPendingReportV1>>
  > = ({ signal }) => feesControllerGetPendingReportV1({ signal });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof feesControllerGetPendingReportV1>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type FeesControllerGetPendingReportV1QueryResult = NonNullable<
  Awaited<ReturnType<typeof feesControllerGetPendingReportV1>>
>;
export type FeesControllerGetPendingReportV1QueryError = unknown;

export function useFeesControllerGetPendingReportV1<
  TData = Awaited<ReturnType<typeof feesControllerGetPendingReportV1>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof feesControllerGetPendingReportV1>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getFeesControllerGetPendingReportV1QueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

export type feesControllerGetDefaultersReportV1Response200 = {
  data: void;
  status: 200;
};

export type feesControllerGetDefaultersReportV1ResponseSuccess =
  feesControllerGetDefaultersReportV1Response200 & {
    headers: Headers;
  };
export type feesControllerGetDefaultersReportV1Response =
  feesControllerGetDefaultersReportV1ResponseSuccess;

export const getFeesControllerGetDefaultersReportV1Url = () => {
  return `http://localhost:3000/api/v1/fees/reports/defaulters`;
};

export const feesControllerGetDefaultersReportV1 = async (
  options?: RequestInit
): Promise<feesControllerGetDefaultersReportV1Response> => {
  return customFetch<feesControllerGetDefaultersReportV1Response>(
    getFeesControllerGetDefaultersReportV1Url(),
    {
      ...options,
      method: "GET",
    }
  );
};

export const getFeesControllerGetDefaultersReportV1InfiniteQueryKey = () => {
  return [
    "infinite",
    `http://localhost:3000/api/v1/fees/reports/defaulters`,
  ] as const;
};

export const getFeesControllerGetDefaultersReportV1QueryKey = () => {
  return [`http://localhost:3000/api/v1/fees/reports/defaulters`] as const;
};

export const getFeesControllerGetDefaultersReportV1InfiniteQueryOptions = <
  TData = Awaited<ReturnType<typeof feesControllerGetDefaultersReportV1>>,
  TError = unknown,
>(options?: {
  query?: UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof feesControllerGetDefaultersReportV1>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getFeesControllerGetDefaultersReportV1InfiniteQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof feesControllerGetDefaultersReportV1>>
  > = ({ signal }) => feesControllerGetDefaultersReportV1({ signal });

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof feesControllerGetDefaultersReportV1>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type FeesControllerGetDefaultersReportV1InfiniteQueryResult =
  NonNullable<Awaited<ReturnType<typeof feesControllerGetDefaultersReportV1>>>;
export type FeesControllerGetDefaultersReportV1InfiniteQueryError = unknown;

export function useFeesControllerGetDefaultersReportV1Infinite<
  TData = Awaited<ReturnType<typeof feesControllerGetDefaultersReportV1>>,
  TError = unknown,
>(options?: {
  query?: UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof feesControllerGetDefaultersReportV1>>,
    TError,
    TData
  >;
}): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions =
    getFeesControllerGetDefaultersReportV1InfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const getFeesControllerGetDefaultersReportV1QueryOptions = <
  TData = Awaited<ReturnType<typeof feesControllerGetDefaultersReportV1>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof feesControllerGetDefaultersReportV1>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFeesControllerGetDefaultersReportV1QueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof feesControllerGetDefaultersReportV1>>
  > = ({ signal }) => feesControllerGetDefaultersReportV1({ signal });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof feesControllerGetDefaultersReportV1>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type FeesControllerGetDefaultersReportV1QueryResult = NonNullable<
  Awaited<ReturnType<typeof feesControllerGetDefaultersReportV1>>
>;
export type FeesControllerGetDefaultersReportV1QueryError = unknown;

export function useFeesControllerGetDefaultersReportV1<
  TData = Awaited<ReturnType<typeof feesControllerGetDefaultersReportV1>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof feesControllerGetDefaultersReportV1>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions =
    getFeesControllerGetDefaultersReportV1QueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

export type feesControllerSendRemindersV1Response200 = {
  data: void;
  status: 200;
};

export type feesControllerSendRemindersV1ResponseSuccess =
  feesControllerSendRemindersV1Response200 & {
    headers: Headers;
  };
export type feesControllerSendRemindersV1Response =
  feesControllerSendRemindersV1ResponseSuccess;

export const getFeesControllerSendRemindersV1Url = () => {
  return `http://localhost:3000/api/v1/fees/send-reminders`;
};

export const feesControllerSendRemindersV1 = async (
  sendRemindersDto: SendRemindersDto,
  options?: RequestInit
): Promise<feesControllerSendRemindersV1Response> => {
  return customFetch<feesControllerSendRemindersV1Response>(
    getFeesControllerSendRemindersV1Url(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(sendRemindersDto),
    }
  );
};

export const getFeesControllerSendRemindersV1MutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof feesControllerSendRemindersV1>>,
    TError,
    { data: SendRemindersDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof feesControllerSendRemindersV1>>,
  TError,
  { data: SendRemindersDto },
  TContext
> => {
  const mutationKey = ["feesControllerSendRemindersV1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof feesControllerSendRemindersV1>>,
    { data: SendRemindersDto }
  > = (props) => {
    const { data } = props ?? {};

    return feesControllerSendRemindersV1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type FeesControllerSendRemindersV1MutationResult = NonNullable<
  Awaited<ReturnType<typeof feesControllerSendRemindersV1>>
>;
export type FeesControllerSendRemindersV1MutationBody = SendRemindersDto;
export type FeesControllerSendRemindersV1MutationError = unknown;

export const useFeesControllerSendRemindersV1 = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof feesControllerSendRemindersV1>>,
    TError,
    { data: SendRemindersDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof feesControllerSendRemindersV1>>,
  TError,
  { data: SendRemindersDto },
  TContext
> => {
  return useMutation(getFeesControllerSendRemindersV1MutationOptions(options));
};
export type feesControllerGetMyChallansV1Response200 = {
  data: void;
  status: 200;
};

export type feesControllerGetMyChallansV1ResponseSuccess =
  feesControllerGetMyChallansV1Response200 & {
    headers: Headers;
  };
export type feesControllerGetMyChallansV1Response =
  feesControllerGetMyChallansV1ResponseSuccess;

export const getFeesControllerGetMyChallansV1Url = () => {
  return `http://localhost:3000/api/v1/fees/my-challans`;
};

export const feesControllerGetMyChallansV1 = async (
  options?: RequestInit
): Promise<feesControllerGetMyChallansV1Response> => {
  return customFetch<feesControllerGetMyChallansV1Response>(
    getFeesControllerGetMyChallansV1Url(),
    {
      ...options,
      method: "GET",
    }
  );
};

export const getFeesControllerGetMyChallansV1InfiniteQueryKey = () => {
  return ["infinite", `http://localhost:3000/api/v1/fees/my-challans`] as const;
};

export const getFeesControllerGetMyChallansV1QueryKey = () => {
  return [`http://localhost:3000/api/v1/fees/my-challans`] as const;
};

export const getFeesControllerGetMyChallansV1InfiniteQueryOptions = <
  TData = Awaited<ReturnType<typeof feesControllerGetMyChallansV1>>,
  TError = unknown,
>(options?: {
  query?: UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof feesControllerGetMyChallansV1>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getFeesControllerGetMyChallansV1InfiniteQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof feesControllerGetMyChallansV1>>
  > = ({ signal }) => feesControllerGetMyChallansV1({ signal });

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof feesControllerGetMyChallansV1>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type FeesControllerGetMyChallansV1InfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof feesControllerGetMyChallansV1>>
>;
export type FeesControllerGetMyChallansV1InfiniteQueryError = unknown;

export function useFeesControllerGetMyChallansV1Infinite<
  TData = Awaited<ReturnType<typeof feesControllerGetMyChallansV1>>,
  TError = unknown,
>(options?: {
  query?: UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof feesControllerGetMyChallansV1>>,
    TError,
    TData
  >;
}): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions =
    getFeesControllerGetMyChallansV1InfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const getFeesControllerGetMyChallansV1QueryOptions = <
  TData = Awaited<ReturnType<typeof feesControllerGetMyChallansV1>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof feesControllerGetMyChallansV1>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFeesControllerGetMyChallansV1QueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof feesControllerGetMyChallansV1>>
  > = ({ signal }) => feesControllerGetMyChallansV1({ signal });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof feesControllerGetMyChallansV1>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type FeesControllerGetMyChallansV1QueryResult = NonNullable<
  Awaited<ReturnType<typeof feesControllerGetMyChallansV1>>
>;
export type FeesControllerGetMyChallansV1QueryError = unknown;

export function useFeesControllerGetMyChallansV1<
  TData = Awaited<ReturnType<typeof feesControllerGetMyChallansV1>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof feesControllerGetMyChallansV1>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getFeesControllerGetMyChallansV1QueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}
