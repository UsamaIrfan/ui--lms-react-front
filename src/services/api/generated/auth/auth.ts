/**
 * Generated by orval v8.4.0 üç∫
 * Do not edit manually.
 * API
 * API docs
 * OpenAPI spec version: 1.0
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AuthAppleLoginDto,
  AuthConfirmEmailDto,
  AuthEmailLoginDto,
  AuthFacebookLoginDto,
  AuthForgotPasswordDto,
  AuthGoogleLoginDto,
  AuthRegisterLoginDto,
  AuthResetPasswordDto,
  AuthSelectTenantDto,
  AuthUpdateDto,
  LoginResponseDto,
  RefreshResponseDto,
  User
} from '.././model';

import { customFetch } from '.././custom-fetch';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



export type authControllerLoginV1Response200 = {
  data: LoginResponseDto
  status: 200
}

export type authControllerLoginV1ResponseSuccess = (authControllerLoginV1Response200) & {
  headers: Headers;
};
;

export type authControllerLoginV1Response = (authControllerLoginV1ResponseSuccess)

export const getAuthControllerLoginV1Url = () => {


  

  return `https://multivendor-updated.vercel.app/api/v1/auth/email/login`
}

export const authControllerLoginV1 = async (authEmailLoginDto: AuthEmailLoginDto, options?: RequestInit): Promise<authControllerLoginV1Response> => {
  
  return customFetch<authControllerLoginV1Response>(getAuthControllerLoginV1Url(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      authEmailLoginDto,)
  }
);}




export const getAuthControllerLoginV1MutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLoginV1>>, TError,{data: AuthEmailLoginDto}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerLoginV1>>, TError,{data: AuthEmailLoginDto}, TContext> => {

const mutationKey = ['authControllerLoginV1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerLoginV1>>, {data: AuthEmailLoginDto}> = (props) => {
          const {data} = props ?? {};

          return  authControllerLoginV1(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerLoginV1MutationResult = NonNullable<Awaited<ReturnType<typeof authControllerLoginV1>>>
    export type AuthControllerLoginV1MutationBody = AuthEmailLoginDto
    export type AuthControllerLoginV1MutationError = unknown

    export const useAuthControllerLoginV1 = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLoginV1>>, TError,{data: AuthEmailLoginDto}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerLoginV1>>,
        TError,
        {data: AuthEmailLoginDto},
        TContext
      > => {
      return useMutation(getAuthControllerLoginV1MutationOptions(options), queryClient);
    }
    export type authControllerRegisterV1Response204 = {
  data: void
  status: 204
}

export type authControllerRegisterV1ResponseSuccess = (authControllerRegisterV1Response204) & {
  headers: Headers;
};
;

export type authControllerRegisterV1Response = (authControllerRegisterV1ResponseSuccess)

export const getAuthControllerRegisterV1Url = () => {


  

  return `https://multivendor-updated.vercel.app/api/v1/auth/email/register`
}

export const authControllerRegisterV1 = async (authRegisterLoginDto: AuthRegisterLoginDto, options?: RequestInit): Promise<authControllerRegisterV1Response> => {
  
  return customFetch<authControllerRegisterV1Response>(getAuthControllerRegisterV1Url(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      authRegisterLoginDto,)
  }
);}




export const getAuthControllerRegisterV1MutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerRegisterV1>>, TError,{data: AuthRegisterLoginDto}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerRegisterV1>>, TError,{data: AuthRegisterLoginDto}, TContext> => {

const mutationKey = ['authControllerRegisterV1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerRegisterV1>>, {data: AuthRegisterLoginDto}> = (props) => {
          const {data} = props ?? {};

          return  authControllerRegisterV1(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerRegisterV1MutationResult = NonNullable<Awaited<ReturnType<typeof authControllerRegisterV1>>>
    export type AuthControllerRegisterV1MutationBody = AuthRegisterLoginDto
    export type AuthControllerRegisterV1MutationError = unknown

    export const useAuthControllerRegisterV1 = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerRegisterV1>>, TError,{data: AuthRegisterLoginDto}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerRegisterV1>>,
        TError,
        {data: AuthRegisterLoginDto},
        TContext
      > => {
      return useMutation(getAuthControllerRegisterV1MutationOptions(options), queryClient);
    }
    export type authControllerConfirmEmailV1Response204 = {
  data: void
  status: 204
}

export type authControllerConfirmEmailV1ResponseSuccess = (authControllerConfirmEmailV1Response204) & {
  headers: Headers;
};
;

export type authControllerConfirmEmailV1Response = (authControllerConfirmEmailV1ResponseSuccess)

export const getAuthControllerConfirmEmailV1Url = () => {


  

  return `https://multivendor-updated.vercel.app/api/v1/auth/email/confirm`
}

export const authControllerConfirmEmailV1 = async (authConfirmEmailDto: AuthConfirmEmailDto, options?: RequestInit): Promise<authControllerConfirmEmailV1Response> => {
  
  return customFetch<authControllerConfirmEmailV1Response>(getAuthControllerConfirmEmailV1Url(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      authConfirmEmailDto,)
  }
);}




export const getAuthControllerConfirmEmailV1MutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerConfirmEmailV1>>, TError,{data: AuthConfirmEmailDto}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerConfirmEmailV1>>, TError,{data: AuthConfirmEmailDto}, TContext> => {

const mutationKey = ['authControllerConfirmEmailV1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerConfirmEmailV1>>, {data: AuthConfirmEmailDto}> = (props) => {
          const {data} = props ?? {};

          return  authControllerConfirmEmailV1(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerConfirmEmailV1MutationResult = NonNullable<Awaited<ReturnType<typeof authControllerConfirmEmailV1>>>
    export type AuthControllerConfirmEmailV1MutationBody = AuthConfirmEmailDto
    export type AuthControllerConfirmEmailV1MutationError = unknown

    export const useAuthControllerConfirmEmailV1 = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerConfirmEmailV1>>, TError,{data: AuthConfirmEmailDto}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerConfirmEmailV1>>,
        TError,
        {data: AuthConfirmEmailDto},
        TContext
      > => {
      return useMutation(getAuthControllerConfirmEmailV1MutationOptions(options), queryClient);
    }
    export type authControllerConfirmNewEmailV1Response204 = {
  data: void
  status: 204
}

export type authControllerConfirmNewEmailV1ResponseSuccess = (authControllerConfirmNewEmailV1Response204) & {
  headers: Headers;
};
;

export type authControllerConfirmNewEmailV1Response = (authControllerConfirmNewEmailV1ResponseSuccess)

export const getAuthControllerConfirmNewEmailV1Url = () => {


  

  return `https://multivendor-updated.vercel.app/api/v1/auth/email/confirm/new`
}

export const authControllerConfirmNewEmailV1 = async (authConfirmEmailDto: AuthConfirmEmailDto, options?: RequestInit): Promise<authControllerConfirmNewEmailV1Response> => {
  
  return customFetch<authControllerConfirmNewEmailV1Response>(getAuthControllerConfirmNewEmailV1Url(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      authConfirmEmailDto,)
  }
);}




export const getAuthControllerConfirmNewEmailV1MutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerConfirmNewEmailV1>>, TError,{data: AuthConfirmEmailDto}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerConfirmNewEmailV1>>, TError,{data: AuthConfirmEmailDto}, TContext> => {

const mutationKey = ['authControllerConfirmNewEmailV1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerConfirmNewEmailV1>>, {data: AuthConfirmEmailDto}> = (props) => {
          const {data} = props ?? {};

          return  authControllerConfirmNewEmailV1(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerConfirmNewEmailV1MutationResult = NonNullable<Awaited<ReturnType<typeof authControllerConfirmNewEmailV1>>>
    export type AuthControllerConfirmNewEmailV1MutationBody = AuthConfirmEmailDto
    export type AuthControllerConfirmNewEmailV1MutationError = unknown

    export const useAuthControllerConfirmNewEmailV1 = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerConfirmNewEmailV1>>, TError,{data: AuthConfirmEmailDto}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerConfirmNewEmailV1>>,
        TError,
        {data: AuthConfirmEmailDto},
        TContext
      > => {
      return useMutation(getAuthControllerConfirmNewEmailV1MutationOptions(options), queryClient);
    }
    export type authControllerForgotPasswordV1Response204 = {
  data: void
  status: 204
}

export type authControllerForgotPasswordV1ResponseSuccess = (authControllerForgotPasswordV1Response204) & {
  headers: Headers;
};
;

export type authControllerForgotPasswordV1Response = (authControllerForgotPasswordV1ResponseSuccess)

export const getAuthControllerForgotPasswordV1Url = () => {


  

  return `https://multivendor-updated.vercel.app/api/v1/auth/forgot/password`
}

export const authControllerForgotPasswordV1 = async (authForgotPasswordDto: AuthForgotPasswordDto, options?: RequestInit): Promise<authControllerForgotPasswordV1Response> => {
  
  return customFetch<authControllerForgotPasswordV1Response>(getAuthControllerForgotPasswordV1Url(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      authForgotPasswordDto,)
  }
);}




export const getAuthControllerForgotPasswordV1MutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerForgotPasswordV1>>, TError,{data: AuthForgotPasswordDto}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerForgotPasswordV1>>, TError,{data: AuthForgotPasswordDto}, TContext> => {

const mutationKey = ['authControllerForgotPasswordV1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerForgotPasswordV1>>, {data: AuthForgotPasswordDto}> = (props) => {
          const {data} = props ?? {};

          return  authControllerForgotPasswordV1(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerForgotPasswordV1MutationResult = NonNullable<Awaited<ReturnType<typeof authControllerForgotPasswordV1>>>
    export type AuthControllerForgotPasswordV1MutationBody = AuthForgotPasswordDto
    export type AuthControllerForgotPasswordV1MutationError = unknown

    export const useAuthControllerForgotPasswordV1 = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerForgotPasswordV1>>, TError,{data: AuthForgotPasswordDto}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerForgotPasswordV1>>,
        TError,
        {data: AuthForgotPasswordDto},
        TContext
      > => {
      return useMutation(getAuthControllerForgotPasswordV1MutationOptions(options), queryClient);
    }
    export type authControllerResetPasswordV1Response204 = {
  data: void
  status: 204
}

export type authControllerResetPasswordV1ResponseSuccess = (authControllerResetPasswordV1Response204) & {
  headers: Headers;
};
;

export type authControllerResetPasswordV1Response = (authControllerResetPasswordV1ResponseSuccess)

export const getAuthControllerResetPasswordV1Url = () => {


  

  return `https://multivendor-updated.vercel.app/api/v1/auth/reset/password`
}

export const authControllerResetPasswordV1 = async (authResetPasswordDto: AuthResetPasswordDto, options?: RequestInit): Promise<authControllerResetPasswordV1Response> => {
  
  return customFetch<authControllerResetPasswordV1Response>(getAuthControllerResetPasswordV1Url(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      authResetPasswordDto,)
  }
);}




export const getAuthControllerResetPasswordV1MutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerResetPasswordV1>>, TError,{data: AuthResetPasswordDto}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerResetPasswordV1>>, TError,{data: AuthResetPasswordDto}, TContext> => {

const mutationKey = ['authControllerResetPasswordV1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerResetPasswordV1>>, {data: AuthResetPasswordDto}> = (props) => {
          const {data} = props ?? {};

          return  authControllerResetPasswordV1(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerResetPasswordV1MutationResult = NonNullable<Awaited<ReturnType<typeof authControllerResetPasswordV1>>>
    export type AuthControllerResetPasswordV1MutationBody = AuthResetPasswordDto
    export type AuthControllerResetPasswordV1MutationError = unknown

    export const useAuthControllerResetPasswordV1 = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerResetPasswordV1>>, TError,{data: AuthResetPasswordDto}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerResetPasswordV1>>,
        TError,
        {data: AuthResetPasswordDto},
        TContext
      > => {
      return useMutation(getAuthControllerResetPasswordV1MutationOptions(options), queryClient);
    }
    export type authControllerMeV1Response200 = {
  data: User
  status: 200
}

export type authControllerMeV1ResponseSuccess = (authControllerMeV1Response200) & {
  headers: Headers;
};
;

export type authControllerMeV1Response = (authControllerMeV1ResponseSuccess)

export const getAuthControllerMeV1Url = () => {


  

  return `https://multivendor-updated.vercel.app/api/v1/auth/me`
}

export const authControllerMeV1 = async ( options?: RequestInit): Promise<authControllerMeV1Response> => {
  
  return customFetch<authControllerMeV1Response>(getAuthControllerMeV1Url(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getAuthControllerMeV1InfiniteQueryKey = () => {
    return [
    'infinite', `https://multivendor-updated.vercel.app/api/v1/auth/me`
    ] as const;
    }

export const getAuthControllerMeV1QueryKey = () => {
    return [
    `https://multivendor-updated.vercel.app/api/v1/auth/me`
    ] as const;
    }

    
export const getAuthControllerMeV1InfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof authControllerMeV1>>>, TError = unknown>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerMeV1>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerMeV1InfiniteQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerMeV1>>> = ({ signal }) => authControllerMeV1({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerMeV1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthControllerMeV1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerMeV1>>>
export type AuthControllerMeV1InfiniteQueryError = unknown


export function useAuthControllerMeV1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerMeV1>>>, TError = unknown>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerMeV1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerMeV1>>,
          TError,
          Awaited<ReturnType<typeof authControllerMeV1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerMeV1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerMeV1>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerMeV1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerMeV1>>,
          TError,
          Awaited<ReturnType<typeof authControllerMeV1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerMeV1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerMeV1>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerMeV1>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAuthControllerMeV1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerMeV1>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerMeV1>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAuthControllerMeV1InfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getAuthControllerMeV1QueryOptions = <TData = Awaited<ReturnType<typeof authControllerMeV1>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerMeV1>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerMeV1QueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerMeV1>>> = ({ signal }) => authControllerMeV1({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof authControllerMeV1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthControllerMeV1QueryResult = NonNullable<Awaited<ReturnType<typeof authControllerMeV1>>>
export type AuthControllerMeV1QueryError = unknown


export function useAuthControllerMeV1<TData = Awaited<ReturnType<typeof authControllerMeV1>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerMeV1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerMeV1>>,
          TError,
          Awaited<ReturnType<typeof authControllerMeV1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerMeV1<TData = Awaited<ReturnType<typeof authControllerMeV1>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerMeV1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerMeV1>>,
          TError,
          Awaited<ReturnType<typeof authControllerMeV1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerMeV1<TData = Awaited<ReturnType<typeof authControllerMeV1>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerMeV1>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAuthControllerMeV1<TData = Awaited<ReturnType<typeof authControllerMeV1>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerMeV1>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAuthControllerMeV1QueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export type authControllerUpdateV1Response200 = {
  data: User
  status: 200
}

export type authControllerUpdateV1ResponseSuccess = (authControllerUpdateV1Response200) & {
  headers: Headers;
};
;

export type authControllerUpdateV1Response = (authControllerUpdateV1ResponseSuccess)

export const getAuthControllerUpdateV1Url = () => {


  

  return `https://multivendor-updated.vercel.app/api/v1/auth/me`
}

export const authControllerUpdateV1 = async (authUpdateDto: AuthUpdateDto, options?: RequestInit): Promise<authControllerUpdateV1Response> => {
  
  return customFetch<authControllerUpdateV1Response>(getAuthControllerUpdateV1Url(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      authUpdateDto,)
  }
);}




export const getAuthControllerUpdateV1MutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerUpdateV1>>, TError,{data: AuthUpdateDto}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerUpdateV1>>, TError,{data: AuthUpdateDto}, TContext> => {

const mutationKey = ['authControllerUpdateV1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerUpdateV1>>, {data: AuthUpdateDto}> = (props) => {
          const {data} = props ?? {};

          return  authControllerUpdateV1(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerUpdateV1MutationResult = NonNullable<Awaited<ReturnType<typeof authControllerUpdateV1>>>
    export type AuthControllerUpdateV1MutationBody = AuthUpdateDto
    export type AuthControllerUpdateV1MutationError = unknown

    export const useAuthControllerUpdateV1 = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerUpdateV1>>, TError,{data: AuthUpdateDto}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerUpdateV1>>,
        TError,
        {data: AuthUpdateDto},
        TContext
      > => {
      return useMutation(getAuthControllerUpdateV1MutationOptions(options), queryClient);
    }
    export type authControllerDeleteV1Response204 = {
  data: void
  status: 204
}

export type authControllerDeleteV1ResponseSuccess = (authControllerDeleteV1Response204) & {
  headers: Headers;
};
;

export type authControllerDeleteV1Response = (authControllerDeleteV1ResponseSuccess)

export const getAuthControllerDeleteV1Url = () => {


  

  return `https://multivendor-updated.vercel.app/api/v1/auth/me`
}

export const authControllerDeleteV1 = async ( options?: RequestInit): Promise<authControllerDeleteV1Response> => {
  
  return customFetch<authControllerDeleteV1Response>(getAuthControllerDeleteV1Url(),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getAuthControllerDeleteV1MutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerDeleteV1>>, TError,void, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerDeleteV1>>, TError,void, TContext> => {

const mutationKey = ['authControllerDeleteV1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerDeleteV1>>, void> = () => {
          

          return  authControllerDeleteV1(requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerDeleteV1MutationResult = NonNullable<Awaited<ReturnType<typeof authControllerDeleteV1>>>
    
    export type AuthControllerDeleteV1MutationError = unknown

    export const useAuthControllerDeleteV1 = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerDeleteV1>>, TError,void, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerDeleteV1>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getAuthControllerDeleteV1MutationOptions(options), queryClient);
    }
    export type authControllerRefreshV1Response200 = {
  data: RefreshResponseDto
  status: 200
}

export type authControllerRefreshV1ResponseSuccess = (authControllerRefreshV1Response200) & {
  headers: Headers;
};
;

export type authControllerRefreshV1Response = (authControllerRefreshV1ResponseSuccess)

export const getAuthControllerRefreshV1Url = () => {


  

  return `https://multivendor-updated.vercel.app/api/v1/auth/refresh`
}

export const authControllerRefreshV1 = async ( options?: RequestInit): Promise<authControllerRefreshV1Response> => {
  
  return customFetch<authControllerRefreshV1Response>(getAuthControllerRefreshV1Url(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getAuthControllerRefreshV1MutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerRefreshV1>>, TError,void, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerRefreshV1>>, TError,void, TContext> => {

const mutationKey = ['authControllerRefreshV1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerRefreshV1>>, void> = () => {
          

          return  authControllerRefreshV1(requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerRefreshV1MutationResult = NonNullable<Awaited<ReturnType<typeof authControllerRefreshV1>>>
    
    export type AuthControllerRefreshV1MutationError = unknown

    export const useAuthControllerRefreshV1 = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerRefreshV1>>, TError,void, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerRefreshV1>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getAuthControllerRefreshV1MutationOptions(options), queryClient);
    }
    export type authControllerLogoutV1Response204 = {
  data: void
  status: 204
}

export type authControllerLogoutV1ResponseSuccess = (authControllerLogoutV1Response204) & {
  headers: Headers;
};
;

export type authControllerLogoutV1Response = (authControllerLogoutV1ResponseSuccess)

export const getAuthControllerLogoutV1Url = () => {


  

  return `https://multivendor-updated.vercel.app/api/v1/auth/logout`
}

export const authControllerLogoutV1 = async ( options?: RequestInit): Promise<authControllerLogoutV1Response> => {
  
  return customFetch<authControllerLogoutV1Response>(getAuthControllerLogoutV1Url(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getAuthControllerLogoutV1MutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLogoutV1>>, TError,void, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerLogoutV1>>, TError,void, TContext> => {

const mutationKey = ['authControllerLogoutV1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerLogoutV1>>, void> = () => {
          

          return  authControllerLogoutV1(requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerLogoutV1MutationResult = NonNullable<Awaited<ReturnType<typeof authControllerLogoutV1>>>
    
    export type AuthControllerLogoutV1MutationError = unknown

    export const useAuthControllerLogoutV1 = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLogoutV1>>, TError,void, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerLogoutV1>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getAuthControllerLogoutV1MutationOptions(options), queryClient);
    }
    export type authControllerSelectTenantV1Response200 = {
  data: LoginResponseDto
  status: 200
}

export type authControllerSelectTenantV1ResponseSuccess = (authControllerSelectTenantV1Response200) & {
  headers: Headers;
};
;

export type authControllerSelectTenantV1Response = (authControllerSelectTenantV1ResponseSuccess)

export const getAuthControllerSelectTenantV1Url = () => {


  

  return `https://multivendor-updated.vercel.app/api/v1/auth/tenant/select`
}

export const authControllerSelectTenantV1 = async (authSelectTenantDto: AuthSelectTenantDto, options?: RequestInit): Promise<authControllerSelectTenantV1Response> => {
  
  return customFetch<authControllerSelectTenantV1Response>(getAuthControllerSelectTenantV1Url(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      authSelectTenantDto,)
  }
);}




export const getAuthControllerSelectTenantV1MutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerSelectTenantV1>>, TError,{data: AuthSelectTenantDto}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerSelectTenantV1>>, TError,{data: AuthSelectTenantDto}, TContext> => {

const mutationKey = ['authControllerSelectTenantV1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerSelectTenantV1>>, {data: AuthSelectTenantDto}> = (props) => {
          const {data} = props ?? {};

          return  authControllerSelectTenantV1(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerSelectTenantV1MutationResult = NonNullable<Awaited<ReturnType<typeof authControllerSelectTenantV1>>>
    export type AuthControllerSelectTenantV1MutationBody = AuthSelectTenantDto
    export type AuthControllerSelectTenantV1MutationError = unknown

    export const useAuthControllerSelectTenantV1 = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerSelectTenantV1>>, TError,{data: AuthSelectTenantDto}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerSelectTenantV1>>,
        TError,
        {data: AuthSelectTenantDto},
        TContext
      > => {
      return useMutation(getAuthControllerSelectTenantV1MutationOptions(options), queryClient);
    }
    export type authControllerGetTenantsV1Response200 = {
  data: void
  status: 200
}

export type authControllerGetTenantsV1ResponseSuccess = (authControllerGetTenantsV1Response200) & {
  headers: Headers;
};
;

export type authControllerGetTenantsV1Response = (authControllerGetTenantsV1ResponseSuccess)

export const getAuthControllerGetTenantsV1Url = () => {


  

  return `https://multivendor-updated.vercel.app/api/v1/auth/tenants`
}

export const authControllerGetTenantsV1 = async ( options?: RequestInit): Promise<authControllerGetTenantsV1Response> => {
  
  return customFetch<authControllerGetTenantsV1Response>(getAuthControllerGetTenantsV1Url(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getAuthControllerGetTenantsV1InfiniteQueryKey = () => {
    return [
    'infinite', `https://multivendor-updated.vercel.app/api/v1/auth/tenants`
    ] as const;
    }

export const getAuthControllerGetTenantsV1QueryKey = () => {
    return [
    `https://multivendor-updated.vercel.app/api/v1/auth/tenants`
    ] as const;
    }

    
export const getAuthControllerGetTenantsV1InfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetTenantsV1>>>, TError = unknown>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetTenantsV1>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerGetTenantsV1InfiniteQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerGetTenantsV1>>> = ({ signal }) => authControllerGetTenantsV1({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetTenantsV1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthControllerGetTenantsV1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerGetTenantsV1>>>
export type AuthControllerGetTenantsV1InfiniteQueryError = unknown


export function useAuthControllerGetTenantsV1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetTenantsV1>>>, TError = unknown>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetTenantsV1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGetTenantsV1>>,
          TError,
          Awaited<ReturnType<typeof authControllerGetTenantsV1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerGetTenantsV1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetTenantsV1>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetTenantsV1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGetTenantsV1>>,
          TError,
          Awaited<ReturnType<typeof authControllerGetTenantsV1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerGetTenantsV1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetTenantsV1>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetTenantsV1>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAuthControllerGetTenantsV1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetTenantsV1>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetTenantsV1>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAuthControllerGetTenantsV1InfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getAuthControllerGetTenantsV1QueryOptions = <TData = Awaited<ReturnType<typeof authControllerGetTenantsV1>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetTenantsV1>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerGetTenantsV1QueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerGetTenantsV1>>> = ({ signal }) => authControllerGetTenantsV1({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof authControllerGetTenantsV1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthControllerGetTenantsV1QueryResult = NonNullable<Awaited<ReturnType<typeof authControllerGetTenantsV1>>>
export type AuthControllerGetTenantsV1QueryError = unknown


export function useAuthControllerGetTenantsV1<TData = Awaited<ReturnType<typeof authControllerGetTenantsV1>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetTenantsV1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGetTenantsV1>>,
          TError,
          Awaited<ReturnType<typeof authControllerGetTenantsV1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerGetTenantsV1<TData = Awaited<ReturnType<typeof authControllerGetTenantsV1>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetTenantsV1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGetTenantsV1>>,
          TError,
          Awaited<ReturnType<typeof authControllerGetTenantsV1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerGetTenantsV1<TData = Awaited<ReturnType<typeof authControllerGetTenantsV1>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetTenantsV1>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAuthControllerGetTenantsV1<TData = Awaited<ReturnType<typeof authControllerGetTenantsV1>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetTenantsV1>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAuthControllerGetTenantsV1QueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export type authFacebookControllerLoginV1Response200 = {
  data: LoginResponseDto
  status: 200
}

export type authFacebookControllerLoginV1ResponseSuccess = (authFacebookControllerLoginV1Response200) & {
  headers: Headers;
};
;

export type authFacebookControllerLoginV1Response = (authFacebookControllerLoginV1ResponseSuccess)

export const getAuthFacebookControllerLoginV1Url = () => {


  

  return `https://multivendor-updated.vercel.app/api/v1/auth/facebook/login`
}

export const authFacebookControllerLoginV1 = async (authFacebookLoginDto: AuthFacebookLoginDto, options?: RequestInit): Promise<authFacebookControllerLoginV1Response> => {
  
  return customFetch<authFacebookControllerLoginV1Response>(getAuthFacebookControllerLoginV1Url(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      authFacebookLoginDto,)
  }
);}




export const getAuthFacebookControllerLoginV1MutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authFacebookControllerLoginV1>>, TError,{data: AuthFacebookLoginDto}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof authFacebookControllerLoginV1>>, TError,{data: AuthFacebookLoginDto}, TContext> => {

const mutationKey = ['authFacebookControllerLoginV1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authFacebookControllerLoginV1>>, {data: AuthFacebookLoginDto}> = (props) => {
          const {data} = props ?? {};

          return  authFacebookControllerLoginV1(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AuthFacebookControllerLoginV1MutationResult = NonNullable<Awaited<ReturnType<typeof authFacebookControllerLoginV1>>>
    export type AuthFacebookControllerLoginV1MutationBody = AuthFacebookLoginDto
    export type AuthFacebookControllerLoginV1MutationError = unknown

    export const useAuthFacebookControllerLoginV1 = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authFacebookControllerLoginV1>>, TError,{data: AuthFacebookLoginDto}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authFacebookControllerLoginV1>>,
        TError,
        {data: AuthFacebookLoginDto},
        TContext
      > => {
      return useMutation(getAuthFacebookControllerLoginV1MutationOptions(options), queryClient);
    }
    export type authGoogleControllerLoginV1Response200 = {
  data: LoginResponseDto
  status: 200
}

export type authGoogleControllerLoginV1ResponseSuccess = (authGoogleControllerLoginV1Response200) & {
  headers: Headers;
};
;

export type authGoogleControllerLoginV1Response = (authGoogleControllerLoginV1ResponseSuccess)

export const getAuthGoogleControllerLoginV1Url = () => {


  

  return `https://multivendor-updated.vercel.app/api/v1/auth/google/login`
}

export const authGoogleControllerLoginV1 = async (authGoogleLoginDto: AuthGoogleLoginDto, options?: RequestInit): Promise<authGoogleControllerLoginV1Response> => {
  
  return customFetch<authGoogleControllerLoginV1Response>(getAuthGoogleControllerLoginV1Url(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      authGoogleLoginDto,)
  }
);}




export const getAuthGoogleControllerLoginV1MutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authGoogleControllerLoginV1>>, TError,{data: AuthGoogleLoginDto}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof authGoogleControllerLoginV1>>, TError,{data: AuthGoogleLoginDto}, TContext> => {

const mutationKey = ['authGoogleControllerLoginV1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authGoogleControllerLoginV1>>, {data: AuthGoogleLoginDto}> = (props) => {
          const {data} = props ?? {};

          return  authGoogleControllerLoginV1(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AuthGoogleControllerLoginV1MutationResult = NonNullable<Awaited<ReturnType<typeof authGoogleControllerLoginV1>>>
    export type AuthGoogleControllerLoginV1MutationBody = AuthGoogleLoginDto
    export type AuthGoogleControllerLoginV1MutationError = unknown

    export const useAuthGoogleControllerLoginV1 = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authGoogleControllerLoginV1>>, TError,{data: AuthGoogleLoginDto}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authGoogleControllerLoginV1>>,
        TError,
        {data: AuthGoogleLoginDto},
        TContext
      > => {
      return useMutation(getAuthGoogleControllerLoginV1MutationOptions(options), queryClient);
    }
    export type authAppleControllerLoginV1Response200 = {
  data: LoginResponseDto
  status: 200
}

export type authAppleControllerLoginV1ResponseSuccess = (authAppleControllerLoginV1Response200) & {
  headers: Headers;
};
;

export type authAppleControllerLoginV1Response = (authAppleControllerLoginV1ResponseSuccess)

export const getAuthAppleControllerLoginV1Url = () => {


  

  return `https://multivendor-updated.vercel.app/api/v1/auth/apple/login`
}

export const authAppleControllerLoginV1 = async (authAppleLoginDto: AuthAppleLoginDto, options?: RequestInit): Promise<authAppleControllerLoginV1Response> => {
  
  return customFetch<authAppleControllerLoginV1Response>(getAuthAppleControllerLoginV1Url(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      authAppleLoginDto,)
  }
);}




export const getAuthAppleControllerLoginV1MutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authAppleControllerLoginV1>>, TError,{data: AuthAppleLoginDto}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof authAppleControllerLoginV1>>, TError,{data: AuthAppleLoginDto}, TContext> => {

const mutationKey = ['authAppleControllerLoginV1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authAppleControllerLoginV1>>, {data: AuthAppleLoginDto}> = (props) => {
          const {data} = props ?? {};

          return  authAppleControllerLoginV1(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AuthAppleControllerLoginV1MutationResult = NonNullable<Awaited<ReturnType<typeof authAppleControllerLoginV1>>>
    export type AuthAppleControllerLoginV1MutationBody = AuthAppleLoginDto
    export type AuthAppleControllerLoginV1MutationError = unknown

    export const useAuthAppleControllerLoginV1 = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authAppleControllerLoginV1>>, TError,{data: AuthAppleLoginDto}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authAppleControllerLoginV1>>,
        TError,
        {data: AuthAppleLoginDto},
        TContext
      > => {
      return useMutation(getAuthAppleControllerLoginV1MutationOptions(options), queryClient);
    }
    