// @ts-nocheck
/**
 * Generated by orval v8.3.0 ðŸº
 * Do not edit manually.
 * API
 * API docs
 * OpenAPI spec version: 1.0
 */
import { useInfiniteQuery, useMutation, useQuery } from "@tanstack/react-query";
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  CreateBranchExpenseDto,
  ExpensesControllerGetConsolidatedReportV1Params,
  ExpensesControllerGetExpenseReportV1Params,
  UpdateBranchExpenseDto,
} from "../../models";

import { customFetch } from "../../custom-fetch";

export type expensesControllerCreateV1Response201 = {
  data: void;
  status: 201;
};

export type expensesControllerCreateV1ResponseSuccess =
  expensesControllerCreateV1Response201 & {
    headers: Headers;
  };
export type expensesControllerCreateV1Response =
  expensesControllerCreateV1ResponseSuccess;

export const getExpensesControllerCreateV1Url = () => {
  return `http://localhost:3000/api/v1/expenses`;
};

export const expensesControllerCreateV1 = async (
  createBranchExpenseDto: CreateBranchExpenseDto,
  options?: RequestInit
): Promise<expensesControllerCreateV1Response> => {
  return customFetch<expensesControllerCreateV1Response>(
    getExpensesControllerCreateV1Url(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(createBranchExpenseDto),
    }
  );
};

export const getExpensesControllerCreateV1MutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof expensesControllerCreateV1>>,
    TError,
    { data: CreateBranchExpenseDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof expensesControllerCreateV1>>,
  TError,
  { data: CreateBranchExpenseDto },
  TContext
> => {
  const mutationKey = ["expensesControllerCreateV1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof expensesControllerCreateV1>>,
    { data: CreateBranchExpenseDto }
  > = (props) => {
    const { data } = props ?? {};

    return expensesControllerCreateV1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ExpensesControllerCreateV1MutationResult = NonNullable<
  Awaited<ReturnType<typeof expensesControllerCreateV1>>
>;
export type ExpensesControllerCreateV1MutationBody = CreateBranchExpenseDto;
export type ExpensesControllerCreateV1MutationError = unknown;

export const useExpensesControllerCreateV1 = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof expensesControllerCreateV1>>,
    TError,
    { data: CreateBranchExpenseDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof expensesControllerCreateV1>>,
  TError,
  { data: CreateBranchExpenseDto },
  TContext
> => {
  return useMutation(getExpensesControllerCreateV1MutationOptions(options));
};
export type expensesControllerFindAllV1Response200 = {
  data: void;
  status: 200;
};

export type expensesControllerFindAllV1ResponseSuccess =
  expensesControllerFindAllV1Response200 & {
    headers: Headers;
  };
export type expensesControllerFindAllV1Response =
  expensesControllerFindAllV1ResponseSuccess;

export const getExpensesControllerFindAllV1Url = () => {
  return `http://localhost:3000/api/v1/expenses`;
};

export const expensesControllerFindAllV1 = async (
  options?: RequestInit
): Promise<expensesControllerFindAllV1Response> => {
  return customFetch<expensesControllerFindAllV1Response>(
    getExpensesControllerFindAllV1Url(),
    {
      ...options,
      method: "GET",
    }
  );
};

export const getExpensesControllerFindAllV1InfiniteQueryKey = () => {
  return ["infinite", `http://localhost:3000/api/v1/expenses`] as const;
};

export const getExpensesControllerFindAllV1QueryKey = () => {
  return [`http://localhost:3000/api/v1/expenses`] as const;
};

export const getExpensesControllerFindAllV1InfiniteQueryOptions = <
  TData = Awaited<ReturnType<typeof expensesControllerFindAllV1>>,
  TError = unknown,
>(options?: {
  query?: UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof expensesControllerFindAllV1>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getExpensesControllerFindAllV1InfiniteQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof expensesControllerFindAllV1>>
  > = ({ signal }) => expensesControllerFindAllV1({ signal });

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof expensesControllerFindAllV1>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ExpensesControllerFindAllV1InfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof expensesControllerFindAllV1>>
>;
export type ExpensesControllerFindAllV1InfiniteQueryError = unknown;

export function useExpensesControllerFindAllV1Infinite<
  TData = Awaited<ReturnType<typeof expensesControllerFindAllV1>>,
  TError = unknown,
>(options?: {
  query?: UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof expensesControllerFindAllV1>>,
    TError,
    TData
  >;
}): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions =
    getExpensesControllerFindAllV1InfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const getExpensesControllerFindAllV1QueryOptions = <
  TData = Awaited<ReturnType<typeof expensesControllerFindAllV1>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof expensesControllerFindAllV1>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getExpensesControllerFindAllV1QueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof expensesControllerFindAllV1>>
  > = ({ signal }) => expensesControllerFindAllV1({ signal });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof expensesControllerFindAllV1>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ExpensesControllerFindAllV1QueryResult = NonNullable<
  Awaited<ReturnType<typeof expensesControllerFindAllV1>>
>;
export type ExpensesControllerFindAllV1QueryError = unknown;

export function useExpensesControllerFindAllV1<
  TData = Awaited<ReturnType<typeof expensesControllerFindAllV1>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof expensesControllerFindAllV1>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getExpensesControllerFindAllV1QueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

export type expensesControllerGetExpenseReportV1Response200 = {
  data: void;
  status: 200;
};

export type expensesControllerGetExpenseReportV1ResponseSuccess =
  expensesControllerGetExpenseReportV1Response200 & {
    headers: Headers;
  };
export type expensesControllerGetExpenseReportV1Response =
  expensesControllerGetExpenseReportV1ResponseSuccess;

export const getExpensesControllerGetExpenseReportV1Url = (
  params?: ExpensesControllerGetExpenseReportV1Params
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `http://localhost:3000/api/v1/expenses/reports?${stringifiedParams}`
    : `http://localhost:3000/api/v1/expenses/reports`;
};

export const expensesControllerGetExpenseReportV1 = async (
  params?: ExpensesControllerGetExpenseReportV1Params,
  options?: RequestInit
): Promise<expensesControllerGetExpenseReportV1Response> => {
  return customFetch<expensesControllerGetExpenseReportV1Response>(
    getExpensesControllerGetExpenseReportV1Url(params),
    {
      ...options,
      method: "GET",
    }
  );
};

export const getExpensesControllerGetExpenseReportV1InfiniteQueryKey = (
  params?: ExpensesControllerGetExpenseReportV1Params
) => {
  return [
    "infinite",
    `http://localhost:3000/api/v1/expenses/reports`,
    ...(params ? [params] : []),
  ] as const;
};

export const getExpensesControllerGetExpenseReportV1QueryKey = (
  params?: ExpensesControllerGetExpenseReportV1Params
) => {
  return [
    `http://localhost:3000/api/v1/expenses/reports`,
    ...(params ? [params] : []),
  ] as const;
};

export const getExpensesControllerGetExpenseReportV1InfiniteQueryOptions = <
  TData = Awaited<ReturnType<typeof expensesControllerGetExpenseReportV1>>,
  TError = unknown,
>(
  params?: ExpensesControllerGetExpenseReportV1Params,
  options?: {
    query?: UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof expensesControllerGetExpenseReportV1>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getExpensesControllerGetExpenseReportV1InfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof expensesControllerGetExpenseReportV1>>
  > = ({ signal, pageParam }) =>
    expensesControllerGetExpenseReportV1(
      { ...params, page: pageParam || params?.["page"] },
      { signal }
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof expensesControllerGetExpenseReportV1>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ExpensesControllerGetExpenseReportV1InfiniteQueryResult =
  NonNullable<Awaited<ReturnType<typeof expensesControllerGetExpenseReportV1>>>;
export type ExpensesControllerGetExpenseReportV1InfiniteQueryError = unknown;

export function useExpensesControllerGetExpenseReportV1Infinite<
  TData = Awaited<ReturnType<typeof expensesControllerGetExpenseReportV1>>,
  TError = unknown,
>(
  params?: ExpensesControllerGetExpenseReportV1Params,
  options?: {
    query?: UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof expensesControllerGetExpenseReportV1>>,
      TError,
      TData
    >;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions =
    getExpensesControllerGetExpenseReportV1InfiniteQueryOptions(
      params,
      options
    );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const getExpensesControllerGetExpenseReportV1QueryOptions = <
  TData = Awaited<ReturnType<typeof expensesControllerGetExpenseReportV1>>,
  TError = unknown,
>(
  params?: ExpensesControllerGetExpenseReportV1Params,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof expensesControllerGetExpenseReportV1>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getExpensesControllerGetExpenseReportV1QueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof expensesControllerGetExpenseReportV1>>
  > = ({ signal }) => expensesControllerGetExpenseReportV1(params, { signal });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof expensesControllerGetExpenseReportV1>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ExpensesControllerGetExpenseReportV1QueryResult = NonNullable<
  Awaited<ReturnType<typeof expensesControllerGetExpenseReportV1>>
>;
export type ExpensesControllerGetExpenseReportV1QueryError = unknown;

export function useExpensesControllerGetExpenseReportV1<
  TData = Awaited<ReturnType<typeof expensesControllerGetExpenseReportV1>>,
  TError = unknown,
>(
  params?: ExpensesControllerGetExpenseReportV1Params,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof expensesControllerGetExpenseReportV1>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getExpensesControllerGetExpenseReportV1QueryOptions(
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

export type expensesControllerGetConsolidatedReportV1Response200 = {
  data: void;
  status: 200;
};

export type expensesControllerGetConsolidatedReportV1ResponseSuccess =
  expensesControllerGetConsolidatedReportV1Response200 & {
    headers: Headers;
  };
export type expensesControllerGetConsolidatedReportV1Response =
  expensesControllerGetConsolidatedReportV1ResponseSuccess;

export const getExpensesControllerGetConsolidatedReportV1Url = (
  params?: ExpensesControllerGetConsolidatedReportV1Params
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `http://localhost:3000/api/v1/expenses/reports/consolidated?${stringifiedParams}`
    : `http://localhost:3000/api/v1/expenses/reports/consolidated`;
};

export const expensesControllerGetConsolidatedReportV1 = async (
  params?: ExpensesControllerGetConsolidatedReportV1Params,
  options?: RequestInit
): Promise<expensesControllerGetConsolidatedReportV1Response> => {
  return customFetch<expensesControllerGetConsolidatedReportV1Response>(
    getExpensesControllerGetConsolidatedReportV1Url(params),
    {
      ...options,
      method: "GET",
    }
  );
};

export const getExpensesControllerGetConsolidatedReportV1InfiniteQueryKey = (
  params?: ExpensesControllerGetConsolidatedReportV1Params
) => {
  return [
    "infinite",
    `http://localhost:3000/api/v1/expenses/reports/consolidated`,
    ...(params ? [params] : []),
  ] as const;
};

export const getExpensesControllerGetConsolidatedReportV1QueryKey = (
  params?: ExpensesControllerGetConsolidatedReportV1Params
) => {
  return [
    `http://localhost:3000/api/v1/expenses/reports/consolidated`,
    ...(params ? [params] : []),
  ] as const;
};

export const getExpensesControllerGetConsolidatedReportV1InfiniteQueryOptions =
  <
    TData = Awaited<
      ReturnType<typeof expensesControllerGetConsolidatedReportV1>
    >,
    TError = unknown,
  >(
    params?: ExpensesControllerGetConsolidatedReportV1Params,
    options?: {
      query?: UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof expensesControllerGetConsolidatedReportV1>>,
        TError,
        TData
      >;
    }
  ) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getExpensesControllerGetConsolidatedReportV1InfiniteQueryKey(params);

    const queryFn: QueryFunction<
      Awaited<ReturnType<typeof expensesControllerGetConsolidatedReportV1>>
    > = ({ signal, pageParam }) =>
      expensesControllerGetConsolidatedReportV1(
        { ...params, page: pageParam || params?.["page"] },
        { signal }
      );

    return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof expensesControllerGetConsolidatedReportV1>>,
      TError,
      TData
    > & { queryKey: QueryKey };
  };

export type ExpensesControllerGetConsolidatedReportV1InfiniteQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof expensesControllerGetConsolidatedReportV1>>
  >;
export type ExpensesControllerGetConsolidatedReportV1InfiniteQueryError =
  unknown;

export function useExpensesControllerGetConsolidatedReportV1Infinite<
  TData = Awaited<ReturnType<typeof expensesControllerGetConsolidatedReportV1>>,
  TError = unknown,
>(
  params?: ExpensesControllerGetConsolidatedReportV1Params,
  options?: {
    query?: UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof expensesControllerGetConsolidatedReportV1>>,
      TError,
      TData
    >;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions =
    getExpensesControllerGetConsolidatedReportV1InfiniteQueryOptions(
      params,
      options
    );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const getExpensesControllerGetConsolidatedReportV1QueryOptions = <
  TData = Awaited<ReturnType<typeof expensesControllerGetConsolidatedReportV1>>,
  TError = unknown,
>(
  params?: ExpensesControllerGetConsolidatedReportV1Params,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof expensesControllerGetConsolidatedReportV1>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getExpensesControllerGetConsolidatedReportV1QueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof expensesControllerGetConsolidatedReportV1>>
  > = ({ signal }) =>
    expensesControllerGetConsolidatedReportV1(params, { signal });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof expensesControllerGetConsolidatedReportV1>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ExpensesControllerGetConsolidatedReportV1QueryResult = NonNullable<
  Awaited<ReturnType<typeof expensesControllerGetConsolidatedReportV1>>
>;
export type ExpensesControllerGetConsolidatedReportV1QueryError = unknown;

export function useExpensesControllerGetConsolidatedReportV1<
  TData = Awaited<ReturnType<typeof expensesControllerGetConsolidatedReportV1>>,
  TError = unknown,
>(
  params?: ExpensesControllerGetConsolidatedReportV1Params,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof expensesControllerGetConsolidatedReportV1>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getExpensesControllerGetConsolidatedReportV1QueryOptions(
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

export type expensesControllerFindByIdV1Response200 = {
  data: void;
  status: 200;
};

export type expensesControllerFindByIdV1ResponseSuccess =
  expensesControllerFindByIdV1Response200 & {
    headers: Headers;
  };
export type expensesControllerFindByIdV1Response =
  expensesControllerFindByIdV1ResponseSuccess;

export const getExpensesControllerFindByIdV1Url = (id: string) => {
  return `http://localhost:3000/api/v1/expenses/${id}`;
};

export const expensesControllerFindByIdV1 = async (
  id: string,
  options?: RequestInit
): Promise<expensesControllerFindByIdV1Response> => {
  return customFetch<expensesControllerFindByIdV1Response>(
    getExpensesControllerFindByIdV1Url(id),
    {
      ...options,
      method: "GET",
    }
  );
};

export const getExpensesControllerFindByIdV1InfiniteQueryKey = (id: string) => {
  return ["infinite", `http://localhost:3000/api/v1/expenses/${id}`] as const;
};

export const getExpensesControllerFindByIdV1QueryKey = (id: string) => {
  return [`http://localhost:3000/api/v1/expenses/${id}`] as const;
};

export const getExpensesControllerFindByIdV1InfiniteQueryOptions = <
  TData = Awaited<ReturnType<typeof expensesControllerFindByIdV1>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof expensesControllerFindByIdV1>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getExpensesControllerFindByIdV1InfiniteQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof expensesControllerFindByIdV1>>
  > = ({ signal }) => expensesControllerFindByIdV1(id, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof expensesControllerFindByIdV1>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ExpensesControllerFindByIdV1InfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof expensesControllerFindByIdV1>>
>;
export type ExpensesControllerFindByIdV1InfiniteQueryError = unknown;

export function useExpensesControllerFindByIdV1Infinite<
  TData = Awaited<ReturnType<typeof expensesControllerFindByIdV1>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof expensesControllerFindByIdV1>>,
      TError,
      TData
    >;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getExpensesControllerFindByIdV1InfiniteQueryOptions(
    id,
    options
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const getExpensesControllerFindByIdV1QueryOptions = <
  TData = Awaited<ReturnType<typeof expensesControllerFindByIdV1>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof expensesControllerFindByIdV1>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getExpensesControllerFindByIdV1QueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof expensesControllerFindByIdV1>>
  > = ({ signal }) => expensesControllerFindByIdV1(id, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof expensesControllerFindByIdV1>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ExpensesControllerFindByIdV1QueryResult = NonNullable<
  Awaited<ReturnType<typeof expensesControllerFindByIdV1>>
>;
export type ExpensesControllerFindByIdV1QueryError = unknown;

export function useExpensesControllerFindByIdV1<
  TData = Awaited<ReturnType<typeof expensesControllerFindByIdV1>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof expensesControllerFindByIdV1>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getExpensesControllerFindByIdV1QueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

export type expensesControllerUpdateV1Response200 = {
  data: void;
  status: 200;
};

export type expensesControllerUpdateV1ResponseSuccess =
  expensesControllerUpdateV1Response200 & {
    headers: Headers;
  };
export type expensesControllerUpdateV1Response =
  expensesControllerUpdateV1ResponseSuccess;

export const getExpensesControllerUpdateV1Url = (id: string) => {
  return `http://localhost:3000/api/v1/expenses/${id}`;
};

export const expensesControllerUpdateV1 = async (
  id: string,
  updateBranchExpenseDto: UpdateBranchExpenseDto,
  options?: RequestInit
): Promise<expensesControllerUpdateV1Response> => {
  return customFetch<expensesControllerUpdateV1Response>(
    getExpensesControllerUpdateV1Url(id),
    {
      ...options,
      method: "PATCH",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(updateBranchExpenseDto),
    }
  );
};

export const getExpensesControllerUpdateV1MutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof expensesControllerUpdateV1>>,
    TError,
    { id: string; data: UpdateBranchExpenseDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof expensesControllerUpdateV1>>,
  TError,
  { id: string; data: UpdateBranchExpenseDto },
  TContext
> => {
  const mutationKey = ["expensesControllerUpdateV1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof expensesControllerUpdateV1>>,
    { id: string; data: UpdateBranchExpenseDto }
  > = (props) => {
    const { id, data } = props ?? {};

    return expensesControllerUpdateV1(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ExpensesControllerUpdateV1MutationResult = NonNullable<
  Awaited<ReturnType<typeof expensesControllerUpdateV1>>
>;
export type ExpensesControllerUpdateV1MutationBody = UpdateBranchExpenseDto;
export type ExpensesControllerUpdateV1MutationError = unknown;

export const useExpensesControllerUpdateV1 = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof expensesControllerUpdateV1>>,
    TError,
    { id: string; data: UpdateBranchExpenseDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof expensesControllerUpdateV1>>,
  TError,
  { id: string; data: UpdateBranchExpenseDto },
  TContext
> => {
  return useMutation(getExpensesControllerUpdateV1MutationOptions(options));
};
export type expensesControllerRemoveV1Response204 = {
  data: void;
  status: 204;
};

export type expensesControllerRemoveV1ResponseSuccess =
  expensesControllerRemoveV1Response204 & {
    headers: Headers;
  };
export type expensesControllerRemoveV1Response =
  expensesControllerRemoveV1ResponseSuccess;

export const getExpensesControllerRemoveV1Url = (id: string) => {
  return `http://localhost:3000/api/v1/expenses/${id}`;
};

export const expensesControllerRemoveV1 = async (
  id: string,
  options?: RequestInit
): Promise<expensesControllerRemoveV1Response> => {
  return customFetch<expensesControllerRemoveV1Response>(
    getExpensesControllerRemoveV1Url(id),
    {
      ...options,
      method: "DELETE",
    }
  );
};

export const getExpensesControllerRemoveV1MutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof expensesControllerRemoveV1>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof expensesControllerRemoveV1>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ["expensesControllerRemoveV1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof expensesControllerRemoveV1>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return expensesControllerRemoveV1(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type ExpensesControllerRemoveV1MutationResult = NonNullable<
  Awaited<ReturnType<typeof expensesControllerRemoveV1>>
>;

export type ExpensesControllerRemoveV1MutationError = unknown;

export const useExpensesControllerRemoveV1 = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof expensesControllerRemoveV1>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof expensesControllerRemoveV1>>,
  TError,
  { id: string },
  TContext
> => {
  return useMutation(getExpensesControllerRemoveV1MutationOptions(options));
};
