/**
 * Generated by orval v8.3.0 üç∫
 * Do not edit manually.
 * API
 * API docs
 * OpenAPI spec version: 1.0
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AddPeriodDto,
  CreateTimetableDto,
  Period,
  Timetable,
  TimetablesControllerCheckConflictsV1Params,
  UpdateTimetableDto
} from '../../models';

import { customFetch } from '../../custom-fetch';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



export type timetablesControllerCreateV1Response201 = {
  data: Timetable
  status: 201
}
    
export type timetablesControllerCreateV1ResponseSuccess = (timetablesControllerCreateV1Response201) & {
  headers: Headers;
};
;

export type timetablesControllerCreateV1Response = (timetablesControllerCreateV1ResponseSuccess)

export const getTimetablesControllerCreateV1Url = () => {


  

  return `http://localhost:3000/api/v1/timetables`
}

export const timetablesControllerCreateV1 = async (createTimetableDto: CreateTimetableDto, options?: RequestInit): Promise<timetablesControllerCreateV1Response> => {
  
  return customFetch<timetablesControllerCreateV1Response>(getTimetablesControllerCreateV1Url(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createTimetableDto,)
  }
);}




export const getTimetablesControllerCreateV1MutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timetablesControllerCreateV1>>, TError,{data: CreateTimetableDto}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof timetablesControllerCreateV1>>, TError,{data: CreateTimetableDto}, TContext> => {

const mutationKey = ['timetablesControllerCreateV1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timetablesControllerCreateV1>>, {data: CreateTimetableDto}> = (props) => {
          const {data} = props ?? {};

          return  timetablesControllerCreateV1(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type TimetablesControllerCreateV1MutationResult = NonNullable<Awaited<ReturnType<typeof timetablesControllerCreateV1>>>
    export type TimetablesControllerCreateV1MutationBody = CreateTimetableDto
    export type TimetablesControllerCreateV1MutationError = unknown

    export const useTimetablesControllerCreateV1 = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timetablesControllerCreateV1>>, TError,{data: CreateTimetableDto}, TContext>, request?: SecondParameter<typeof customFetch>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof timetablesControllerCreateV1>>,
        TError,
        {data: CreateTimetableDto},
        TContext
      > => {
      return useMutation(getTimetablesControllerCreateV1MutationOptions(options));
    }
    export type timetablesControllerFindAllV1Response200 = {
  data: Timetable[]
  status: 200
}
    
export type timetablesControllerFindAllV1ResponseSuccess = (timetablesControllerFindAllV1Response200) & {
  headers: Headers;
};
;

export type timetablesControllerFindAllV1Response = (timetablesControllerFindAllV1ResponseSuccess)

export const getTimetablesControllerFindAllV1Url = () => {


  

  return `http://localhost:3000/api/v1/timetables`
}

export const timetablesControllerFindAllV1 = async ( options?: RequestInit): Promise<timetablesControllerFindAllV1Response> => {
  
  return customFetch<timetablesControllerFindAllV1Response>(getTimetablesControllerFindAllV1Url(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getTimetablesControllerFindAllV1InfiniteQueryKey = () => {
    return [
    'infinite', `http://localhost:3000/api/v1/timetables`
    ] as const;
    }

export const getTimetablesControllerFindAllV1QueryKey = () => {
    return [
    `http://localhost:3000/api/v1/timetables`
    ] as const;
    }

    
export const getTimetablesControllerFindAllV1InfiniteQueryOptions = <TData = Awaited<ReturnType<typeof timetablesControllerFindAllV1>>, TError = unknown>( options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof timetablesControllerFindAllV1>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimetablesControllerFindAllV1InfiniteQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timetablesControllerFindAllV1>>> = ({ signal }) => timetablesControllerFindAllV1({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof timetablesControllerFindAllV1>>, TError, TData> & { queryKey: QueryKey }
}

export type TimetablesControllerFindAllV1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof timetablesControllerFindAllV1>>>
export type TimetablesControllerFindAllV1InfiniteQueryError = unknown



export function useTimetablesControllerFindAllV1Infinite<TData = Awaited<ReturnType<typeof timetablesControllerFindAllV1>>, TError = unknown>(
  options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof timetablesControllerFindAllV1>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getTimetablesControllerFindAllV1InfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getTimetablesControllerFindAllV1QueryOptions = <TData = Awaited<ReturnType<typeof timetablesControllerFindAllV1>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof timetablesControllerFindAllV1>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimetablesControllerFindAllV1QueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timetablesControllerFindAllV1>>> = ({ signal }) => timetablesControllerFindAllV1({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof timetablesControllerFindAllV1>>, TError, TData> & { queryKey: QueryKey }
}

export type TimetablesControllerFindAllV1QueryResult = NonNullable<Awaited<ReturnType<typeof timetablesControllerFindAllV1>>>
export type TimetablesControllerFindAllV1QueryError = unknown



export function useTimetablesControllerFindAllV1<TData = Awaited<ReturnType<typeof timetablesControllerFindAllV1>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof timetablesControllerFindAllV1>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getTimetablesControllerFindAllV1QueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}




export type timetablesControllerFindByBranchV1Response200 = {
  data: Timetable[]
  status: 200
}
    
export type timetablesControllerFindByBranchV1ResponseSuccess = (timetablesControllerFindByBranchV1Response200) & {
  headers: Headers;
};
;

export type timetablesControllerFindByBranchV1Response = (timetablesControllerFindByBranchV1ResponseSuccess)

export const getTimetablesControllerFindByBranchV1Url = (branchId: string,) => {


  

  return `http://localhost:3000/api/v1/timetables/branch/${branchId}`
}

export const timetablesControllerFindByBranchV1 = async (branchId: string, options?: RequestInit): Promise<timetablesControllerFindByBranchV1Response> => {
  
  return customFetch<timetablesControllerFindByBranchV1Response>(getTimetablesControllerFindByBranchV1Url(branchId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getTimetablesControllerFindByBranchV1InfiniteQueryKey = (branchId: string,) => {
    return [
    'infinite', `http://localhost:3000/api/v1/timetables/branch/${branchId}`
    ] as const;
    }

export const getTimetablesControllerFindByBranchV1QueryKey = (branchId: string,) => {
    return [
    `http://localhost:3000/api/v1/timetables/branch/${branchId}`
    ] as const;
    }

    
export const getTimetablesControllerFindByBranchV1InfiniteQueryOptions = <TData = Awaited<ReturnType<typeof timetablesControllerFindByBranchV1>>, TError = unknown>(branchId: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof timetablesControllerFindByBranchV1>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimetablesControllerFindByBranchV1InfiniteQueryKey(branchId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timetablesControllerFindByBranchV1>>> = ({ signal }) => timetablesControllerFindByBranchV1(branchId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(branchId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof timetablesControllerFindByBranchV1>>, TError, TData> & { queryKey: QueryKey }
}

export type TimetablesControllerFindByBranchV1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof timetablesControllerFindByBranchV1>>>
export type TimetablesControllerFindByBranchV1InfiniteQueryError = unknown



export function useTimetablesControllerFindByBranchV1Infinite<TData = Awaited<ReturnType<typeof timetablesControllerFindByBranchV1>>, TError = unknown>(
 branchId: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof timetablesControllerFindByBranchV1>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getTimetablesControllerFindByBranchV1InfiniteQueryOptions(branchId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getTimetablesControllerFindByBranchV1QueryOptions = <TData = Awaited<ReturnType<typeof timetablesControllerFindByBranchV1>>, TError = unknown>(branchId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof timetablesControllerFindByBranchV1>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimetablesControllerFindByBranchV1QueryKey(branchId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timetablesControllerFindByBranchV1>>> = ({ signal }) => timetablesControllerFindByBranchV1(branchId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(branchId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof timetablesControllerFindByBranchV1>>, TError, TData> & { queryKey: QueryKey }
}

export type TimetablesControllerFindByBranchV1QueryResult = NonNullable<Awaited<ReturnType<typeof timetablesControllerFindByBranchV1>>>
export type TimetablesControllerFindByBranchV1QueryError = unknown



export function useTimetablesControllerFindByBranchV1<TData = Awaited<ReturnType<typeof timetablesControllerFindByBranchV1>>, TError = unknown>(
 branchId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof timetablesControllerFindByBranchV1>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getTimetablesControllerFindByBranchV1QueryOptions(branchId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}




export type timetablesControllerCheckConflictsV1Response200 = {
  data: Period[]
  status: 200
}
    
export type timetablesControllerCheckConflictsV1ResponseSuccess = (timetablesControllerCheckConflictsV1Response200) & {
  headers: Headers;
};
;

export type timetablesControllerCheckConflictsV1Response = (timetablesControllerCheckConflictsV1ResponseSuccess)

export const getTimetablesControllerCheckConflictsV1Url = (params: TimetablesControllerCheckConflictsV1Params,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:3000/api/v1/timetables/conflicts?${stringifiedParams}` : `http://localhost:3000/api/v1/timetables/conflicts`
}

export const timetablesControllerCheckConflictsV1 = async (params: TimetablesControllerCheckConflictsV1Params, options?: RequestInit): Promise<timetablesControllerCheckConflictsV1Response> => {
  
  return customFetch<timetablesControllerCheckConflictsV1Response>(getTimetablesControllerCheckConflictsV1Url(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getTimetablesControllerCheckConflictsV1InfiniteQueryKey = (params?: TimetablesControllerCheckConflictsV1Params,) => {
    return [
    'infinite', `http://localhost:3000/api/v1/timetables/conflicts`, ...(params ? [params] : [])
    ] as const;
    }

export const getTimetablesControllerCheckConflictsV1QueryKey = (params?: TimetablesControllerCheckConflictsV1Params,) => {
    return [
    `http://localhost:3000/api/v1/timetables/conflicts`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getTimetablesControllerCheckConflictsV1InfiniteQueryOptions = <TData = Awaited<ReturnType<typeof timetablesControllerCheckConflictsV1>>, TError = unknown>(params: TimetablesControllerCheckConflictsV1Params, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof timetablesControllerCheckConflictsV1>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimetablesControllerCheckConflictsV1InfiniteQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timetablesControllerCheckConflictsV1>>> = ({ signal, pageParam }) => timetablesControllerCheckConflictsV1({...params, 'page': pageParam || params?.['page']}, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof timetablesControllerCheckConflictsV1>>, TError, TData> & { queryKey: QueryKey }
}

export type TimetablesControllerCheckConflictsV1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof timetablesControllerCheckConflictsV1>>>
export type TimetablesControllerCheckConflictsV1InfiniteQueryError = unknown



export function useTimetablesControllerCheckConflictsV1Infinite<TData = Awaited<ReturnType<typeof timetablesControllerCheckConflictsV1>>, TError = unknown>(
 params: TimetablesControllerCheckConflictsV1Params, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof timetablesControllerCheckConflictsV1>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getTimetablesControllerCheckConflictsV1InfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getTimetablesControllerCheckConflictsV1QueryOptions = <TData = Awaited<ReturnType<typeof timetablesControllerCheckConflictsV1>>, TError = unknown>(params: TimetablesControllerCheckConflictsV1Params, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof timetablesControllerCheckConflictsV1>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimetablesControllerCheckConflictsV1QueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timetablesControllerCheckConflictsV1>>> = ({ signal }) => timetablesControllerCheckConflictsV1(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof timetablesControllerCheckConflictsV1>>, TError, TData> & { queryKey: QueryKey }
}

export type TimetablesControllerCheckConflictsV1QueryResult = NonNullable<Awaited<ReturnType<typeof timetablesControllerCheckConflictsV1>>>
export type TimetablesControllerCheckConflictsV1QueryError = unknown



export function useTimetablesControllerCheckConflictsV1<TData = Awaited<ReturnType<typeof timetablesControllerCheckConflictsV1>>, TError = unknown>(
 params: TimetablesControllerCheckConflictsV1Params, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof timetablesControllerCheckConflictsV1>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getTimetablesControllerCheckConflictsV1QueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}




export type timetablesControllerFindOneV1Response200 = {
  data: Timetable
  status: 200
}
    
export type timetablesControllerFindOneV1ResponseSuccess = (timetablesControllerFindOneV1Response200) & {
  headers: Headers;
};
;

export type timetablesControllerFindOneV1Response = (timetablesControllerFindOneV1ResponseSuccess)

export const getTimetablesControllerFindOneV1Url = (id: string,) => {


  

  return `http://localhost:3000/api/v1/timetables/${id}`
}

export const timetablesControllerFindOneV1 = async (id: string, options?: RequestInit): Promise<timetablesControllerFindOneV1Response> => {
  
  return customFetch<timetablesControllerFindOneV1Response>(getTimetablesControllerFindOneV1Url(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getTimetablesControllerFindOneV1InfiniteQueryKey = (id: string,) => {
    return [
    'infinite', `http://localhost:3000/api/v1/timetables/${id}`
    ] as const;
    }

export const getTimetablesControllerFindOneV1QueryKey = (id: string,) => {
    return [
    `http://localhost:3000/api/v1/timetables/${id}`
    ] as const;
    }

    
export const getTimetablesControllerFindOneV1InfiniteQueryOptions = <TData = Awaited<ReturnType<typeof timetablesControllerFindOneV1>>, TError = unknown>(id: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof timetablesControllerFindOneV1>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimetablesControllerFindOneV1InfiniteQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timetablesControllerFindOneV1>>> = ({ signal }) => timetablesControllerFindOneV1(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof timetablesControllerFindOneV1>>, TError, TData> & { queryKey: QueryKey }
}

export type TimetablesControllerFindOneV1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof timetablesControllerFindOneV1>>>
export type TimetablesControllerFindOneV1InfiniteQueryError = unknown



export function useTimetablesControllerFindOneV1Infinite<TData = Awaited<ReturnType<typeof timetablesControllerFindOneV1>>, TError = unknown>(
 id: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof timetablesControllerFindOneV1>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getTimetablesControllerFindOneV1InfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getTimetablesControllerFindOneV1QueryOptions = <TData = Awaited<ReturnType<typeof timetablesControllerFindOneV1>>, TError = unknown>(id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof timetablesControllerFindOneV1>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimetablesControllerFindOneV1QueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timetablesControllerFindOneV1>>> = ({ signal }) => timetablesControllerFindOneV1(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof timetablesControllerFindOneV1>>, TError, TData> & { queryKey: QueryKey }
}

export type TimetablesControllerFindOneV1QueryResult = NonNullable<Awaited<ReturnType<typeof timetablesControllerFindOneV1>>>
export type TimetablesControllerFindOneV1QueryError = unknown



export function useTimetablesControllerFindOneV1<TData = Awaited<ReturnType<typeof timetablesControllerFindOneV1>>, TError = unknown>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof timetablesControllerFindOneV1>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getTimetablesControllerFindOneV1QueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}




export type timetablesControllerUpdateV1Response200 = {
  data: Timetable
  status: 200
}
    
export type timetablesControllerUpdateV1ResponseSuccess = (timetablesControllerUpdateV1Response200) & {
  headers: Headers;
};
;

export type timetablesControllerUpdateV1Response = (timetablesControllerUpdateV1ResponseSuccess)

export const getTimetablesControllerUpdateV1Url = (id: string,) => {


  

  return `http://localhost:3000/api/v1/timetables/${id}`
}

export const timetablesControllerUpdateV1 = async (id: string,
    updateTimetableDto: UpdateTimetableDto, options?: RequestInit): Promise<timetablesControllerUpdateV1Response> => {
  
  return customFetch<timetablesControllerUpdateV1Response>(getTimetablesControllerUpdateV1Url(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateTimetableDto,)
  }
);}




export const getTimetablesControllerUpdateV1MutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timetablesControllerUpdateV1>>, TError,{id: string;data: UpdateTimetableDto}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof timetablesControllerUpdateV1>>, TError,{id: string;data: UpdateTimetableDto}, TContext> => {

const mutationKey = ['timetablesControllerUpdateV1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timetablesControllerUpdateV1>>, {id: string;data: UpdateTimetableDto}> = (props) => {
          const {id,data} = props ?? {};

          return  timetablesControllerUpdateV1(id,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type TimetablesControllerUpdateV1MutationResult = NonNullable<Awaited<ReturnType<typeof timetablesControllerUpdateV1>>>
    export type TimetablesControllerUpdateV1MutationBody = UpdateTimetableDto
    export type TimetablesControllerUpdateV1MutationError = unknown

    export const useTimetablesControllerUpdateV1 = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timetablesControllerUpdateV1>>, TError,{id: string;data: UpdateTimetableDto}, TContext>, request?: SecondParameter<typeof customFetch>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof timetablesControllerUpdateV1>>,
        TError,
        {id: string;data: UpdateTimetableDto},
        TContext
      > => {
      return useMutation(getTimetablesControllerUpdateV1MutationOptions(options));
    }
    export type timetablesControllerRemoveV1Response204 = {
  data: void
  status: 204
}
    
export type timetablesControllerRemoveV1ResponseSuccess = (timetablesControllerRemoveV1Response204) & {
  headers: Headers;
};
;

export type timetablesControllerRemoveV1Response = (timetablesControllerRemoveV1ResponseSuccess)

export const getTimetablesControllerRemoveV1Url = (id: string,) => {


  

  return `http://localhost:3000/api/v1/timetables/${id}`
}

export const timetablesControllerRemoveV1 = async (id: string, options?: RequestInit): Promise<timetablesControllerRemoveV1Response> => {
  
  return customFetch<timetablesControllerRemoveV1Response>(getTimetablesControllerRemoveV1Url(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getTimetablesControllerRemoveV1MutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timetablesControllerRemoveV1>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof timetablesControllerRemoveV1>>, TError,{id: string}, TContext> => {

const mutationKey = ['timetablesControllerRemoveV1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timetablesControllerRemoveV1>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  timetablesControllerRemoveV1(id,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type TimetablesControllerRemoveV1MutationResult = NonNullable<Awaited<ReturnType<typeof timetablesControllerRemoveV1>>>
    
    export type TimetablesControllerRemoveV1MutationError = unknown

    export const useTimetablesControllerRemoveV1 = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timetablesControllerRemoveV1>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof timetablesControllerRemoveV1>>,
        TError,
        {id: string},
        TContext
      > => {
      return useMutation(getTimetablesControllerRemoveV1MutationOptions(options));
    }
    export type timetablesControllerAddPeriodV1Response201 = {
  data: Period
  status: 201
}
    
export type timetablesControllerAddPeriodV1ResponseSuccess = (timetablesControllerAddPeriodV1Response201) & {
  headers: Headers;
};
;

export type timetablesControllerAddPeriodV1Response = (timetablesControllerAddPeriodV1ResponseSuccess)

export const getTimetablesControllerAddPeriodV1Url = (id: string,) => {


  

  return `http://localhost:3000/api/v1/timetables/${id}/periods`
}

export const timetablesControllerAddPeriodV1 = async (id: string,
    addPeriodDto: AddPeriodDto, options?: RequestInit): Promise<timetablesControllerAddPeriodV1Response> => {
  
  return customFetch<timetablesControllerAddPeriodV1Response>(getTimetablesControllerAddPeriodV1Url(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      addPeriodDto,)
  }
);}




export const getTimetablesControllerAddPeriodV1MutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timetablesControllerAddPeriodV1>>, TError,{id: string;data: AddPeriodDto}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof timetablesControllerAddPeriodV1>>, TError,{id: string;data: AddPeriodDto}, TContext> => {

const mutationKey = ['timetablesControllerAddPeriodV1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timetablesControllerAddPeriodV1>>, {id: string;data: AddPeriodDto}> = (props) => {
          const {id,data} = props ?? {};

          return  timetablesControllerAddPeriodV1(id,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type TimetablesControllerAddPeriodV1MutationResult = NonNullable<Awaited<ReturnType<typeof timetablesControllerAddPeriodV1>>>
    export type TimetablesControllerAddPeriodV1MutationBody = AddPeriodDto
    export type TimetablesControllerAddPeriodV1MutationError = unknown

    export const useTimetablesControllerAddPeriodV1 = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timetablesControllerAddPeriodV1>>, TError,{id: string;data: AddPeriodDto}, TContext>, request?: SecondParameter<typeof customFetch>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof timetablesControllerAddPeriodV1>>,
        TError,
        {id: string;data: AddPeriodDto},
        TContext
      > => {
      return useMutation(getTimetablesControllerAddPeriodV1MutationOptions(options));
    }
    export type timetablesControllerFindPeriodsV1Response200 = {
  data: Period[]
  status: 200
}
    
export type timetablesControllerFindPeriodsV1ResponseSuccess = (timetablesControllerFindPeriodsV1Response200) & {
  headers: Headers;
};
;

export type timetablesControllerFindPeriodsV1Response = (timetablesControllerFindPeriodsV1ResponseSuccess)

export const getTimetablesControllerFindPeriodsV1Url = (id: string,) => {


  

  return `http://localhost:3000/api/v1/timetables/${id}/periods`
}

export const timetablesControllerFindPeriodsV1 = async (id: string, options?: RequestInit): Promise<timetablesControllerFindPeriodsV1Response> => {
  
  return customFetch<timetablesControllerFindPeriodsV1Response>(getTimetablesControllerFindPeriodsV1Url(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getTimetablesControllerFindPeriodsV1InfiniteQueryKey = (id: string,) => {
    return [
    'infinite', `http://localhost:3000/api/v1/timetables/${id}/periods`
    ] as const;
    }

export const getTimetablesControllerFindPeriodsV1QueryKey = (id: string,) => {
    return [
    `http://localhost:3000/api/v1/timetables/${id}/periods`
    ] as const;
    }

    
export const getTimetablesControllerFindPeriodsV1InfiniteQueryOptions = <TData = Awaited<ReturnType<typeof timetablesControllerFindPeriodsV1>>, TError = unknown>(id: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof timetablesControllerFindPeriodsV1>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimetablesControllerFindPeriodsV1InfiniteQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timetablesControllerFindPeriodsV1>>> = ({ signal }) => timetablesControllerFindPeriodsV1(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof timetablesControllerFindPeriodsV1>>, TError, TData> & { queryKey: QueryKey }
}

export type TimetablesControllerFindPeriodsV1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof timetablesControllerFindPeriodsV1>>>
export type TimetablesControllerFindPeriodsV1InfiniteQueryError = unknown



export function useTimetablesControllerFindPeriodsV1Infinite<TData = Awaited<ReturnType<typeof timetablesControllerFindPeriodsV1>>, TError = unknown>(
 id: string, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof timetablesControllerFindPeriodsV1>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getTimetablesControllerFindPeriodsV1InfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getTimetablesControllerFindPeriodsV1QueryOptions = <TData = Awaited<ReturnType<typeof timetablesControllerFindPeriodsV1>>, TError = unknown>(id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof timetablesControllerFindPeriodsV1>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTimetablesControllerFindPeriodsV1QueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof timetablesControllerFindPeriodsV1>>> = ({ signal }) => timetablesControllerFindPeriodsV1(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof timetablesControllerFindPeriodsV1>>, TError, TData> & { queryKey: QueryKey }
}

export type TimetablesControllerFindPeriodsV1QueryResult = NonNullable<Awaited<ReturnType<typeof timetablesControllerFindPeriodsV1>>>
export type TimetablesControllerFindPeriodsV1QueryError = unknown



export function useTimetablesControllerFindPeriodsV1<TData = Awaited<ReturnType<typeof timetablesControllerFindPeriodsV1>>, TError = unknown>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof timetablesControllerFindPeriodsV1>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getTimetablesControllerFindPeriodsV1QueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}




export type timetablesControllerRemovePeriodV1Response204 = {
  data: void
  status: 204
}
    
export type timetablesControllerRemovePeriodV1ResponseSuccess = (timetablesControllerRemovePeriodV1Response204) & {
  headers: Headers;
};
;

export type timetablesControllerRemovePeriodV1Response = (timetablesControllerRemovePeriodV1ResponseSuccess)

export const getTimetablesControllerRemovePeriodV1Url = (periodId: string,) => {


  

  return `http://localhost:3000/api/v1/timetables/periods/${periodId}`
}

export const timetablesControllerRemovePeriodV1 = async (periodId: string, options?: RequestInit): Promise<timetablesControllerRemovePeriodV1Response> => {
  
  return customFetch<timetablesControllerRemovePeriodV1Response>(getTimetablesControllerRemovePeriodV1Url(periodId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getTimetablesControllerRemovePeriodV1MutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timetablesControllerRemovePeriodV1>>, TError,{periodId: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof timetablesControllerRemovePeriodV1>>, TError,{periodId: string}, TContext> => {

const mutationKey = ['timetablesControllerRemovePeriodV1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof timetablesControllerRemovePeriodV1>>, {periodId: string}> = (props) => {
          const {periodId} = props ?? {};

          return  timetablesControllerRemovePeriodV1(periodId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type TimetablesControllerRemovePeriodV1MutationResult = NonNullable<Awaited<ReturnType<typeof timetablesControllerRemovePeriodV1>>>
    
    export type TimetablesControllerRemovePeriodV1MutationError = unknown

    export const useTimetablesControllerRemovePeriodV1 = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof timetablesControllerRemovePeriodV1>>, TError,{periodId: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof timetablesControllerRemovePeriodV1>>,
        TError,
        {periodId: string},
        TContext
      > => {
      return useMutation(getTimetablesControllerRemovePeriodV1MutationOptions(options));
    }
    